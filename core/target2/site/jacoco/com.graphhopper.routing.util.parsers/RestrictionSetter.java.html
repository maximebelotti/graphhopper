<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RestrictionSetter.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.util.parsers</a> &gt; <span class="el_source">RestrictionSetter.java</span></div><h1>RestrictionSetter.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.graphhopper.routing.util.parsers;

import com.carrotsearch.hppc.BitSet;
import com.carrotsearch.hppc.*;
import com.carrotsearch.hppc.cursors.IntCursor;
import com.carrotsearch.hppc.procedures.IntProcedure;
import com.carrotsearch.hppc.procedures.LongIntProcedure;
import com.graphhopper.reader.osm.Pair;
import com.graphhopper.routing.ev.BooleanEncodedValue;
import com.graphhopper.storage.BaseGraph;
import com.graphhopper.util.BitUtil;
import com.graphhopper.util.*;

import java.util.*;

import static com.graphhopper.util.EdgeIteratorState.REVERSE_STATE;

/**
 * Used to add via-node and via-edge restrictions to a given graph. Via-edge restrictions are realized
 * by augmenting the graph with artificial edges. For proper handling of overlapping turn restrictions
 * (turn restrictions that share the same via-edges) and turn restrictions for different encoded values
 * it is important to add all restrictions with a single call.
 */
public class RestrictionSetter {
<span class="fc" id="L43">    private static final IntSet EMPTY_SET = IntHashSet.from();</span>
    private final BaseGraph baseGraph;
    private final List&lt;BooleanEncodedValue&gt; turnRestrictionEncs;

<span class="fc" id="L47">    public RestrictionSetter(BaseGraph baseGraph, List&lt;BooleanEncodedValue&gt; turnRestrictionEncs) {</span>
<span class="fc" id="L48">        this.baseGraph = baseGraph;</span>
<span class="fc" id="L49">        this.turnRestrictionEncs = turnRestrictionEncs;</span>
<span class="fc" id="L50">    }</span>

    public static Restriction createViaNodeRestriction(int fromEdge, int viaNode, int toEdge) {
<span class="fc" id="L53">        return new Restriction(IntArrayList.from(fromEdge, toEdge), viaNode);</span>
    }

    public static Restriction createViaEdgeRestriction(IntArrayList edges) {
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (edges.size() &lt; 3)</span>
<span class="nc" id="L58">            throw new IllegalArgumentException(&quot;Via-edge restrictions must have at least three edges, but got: &quot; + edges.size());</span>
<span class="fc" id="L59">        return new Restriction(edges, -1);</span>
    }

    public void setRestrictions(List&lt;Restriction&gt; restrictions, List&lt;BitSet&gt; encBits) {
<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (restrictions.size() != encBits.size())</span>
<span class="nc" id="L64">            throw new IllegalArgumentException(&quot;There must be as many encBits as restrictions. Got: &quot; + encBits.size() + &quot; and &quot; + restrictions.size());</span>
<span class="fc" id="L65">        List&lt;InternalRestriction&gt; internalRestrictions = restrictions.stream().map(this::convertToInternal).toList();</span>
<span class="fc" id="L66">        disableRedundantRestrictions(internalRestrictions, encBits);</span>
<span class="fc" id="L67">        LongIntMap artificialEdgeKeysByIncViaPairs = new LongIntScatterMap();</span>
<span class="fc" id="L68">        IntObjectMap&lt;IntSet&gt; artificialEdgesByEdge = new IntObjectScatterMap&lt;&gt;();</span>
<span class="fc bfc" id="L69" title="All 2 branches covered.">        for (int i = 0; i &lt; internalRestrictions.size(); i++) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">            if (encBits.get(i).cardinality() &lt; 1) continue;</span>
<span class="fc" id="L71">            InternalRestriction restriction = internalRestrictions.get(i);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">            if (restriction.getEdgeKeys().size() &lt; 3)</span>
<span class="fc" id="L73">                continue;</span>
<span class="fc" id="L74">            int incomingEdge = restriction.getFromEdge();</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            for (int j = 1; j &lt; restriction.getEdgeKeys().size() - 1; ++j) {</span>
<span class="fc" id="L76">                int viaEdgeKey = restriction.getEdgeKeys().get(j);</span>
<span class="fc" id="L77">                long key = BitUtil.LITTLE.toLong(incomingEdge, viaEdgeKey);</span>
                int artificialEdgeKey;
<span class="fc bfc" id="L79" title="All 2 branches covered.">                if (artificialEdgeKeysByIncViaPairs.containsKey(key)) {</span>
<span class="fc" id="L80">                    artificialEdgeKey = artificialEdgeKeysByIncViaPairs.get(key);</span>
                } else {
<span class="fc" id="L82">                    int viaEdge = GHUtility.getEdgeFromEdgeKey(viaEdgeKey);</span>
<span class="fc" id="L83">                    EdgeIteratorState artificialEdgeState = baseGraph.copyEdge(viaEdge, true);</span>
<span class="fc" id="L84">                    int artificialEdge = artificialEdgeState.getEdge();</span>
<span class="fc bfc" id="L85" title="All 2 branches covered.">                    if (artificialEdgesByEdge.containsKey(viaEdge)) {</span>
<span class="fc" id="L86">                        IntSet artificialEdges = artificialEdgesByEdge.get(viaEdge);</span>
<span class="fc" id="L87">                        artificialEdges.forEach((IntProcedure) a -&gt; {</span>
<span class="fc bfc" id="L88" title="All 2 branches covered.">                            for (BooleanEncodedValue turnRestrictionEnc : turnRestrictionEncs)</span>
<span class="fc" id="L89">                                restrictTurnsBetweenEdges(turnRestrictionEnc, artificialEdgeState, a);</span>
<span class="fc" id="L90">                        });</span>
<span class="fc" id="L91">                        artificialEdges.add(artificialEdge);</span>
<span class="fc" id="L92">                    } else {</span>
<span class="fc" id="L93">                        IntSet artificialEdges = new IntScatterSet();</span>
<span class="fc" id="L94">                        artificialEdges.add(artificialEdge);</span>
<span class="fc" id="L95">                        artificialEdgesByEdge.put(viaEdge, artificialEdges);</span>
                    }
<span class="fc bfc" id="L97" title="All 2 branches covered.">                    for (BooleanEncodedValue turnRestrictionEnc : turnRestrictionEncs)</span>
<span class="fc" id="L98">                        restrictTurnsBetweenEdges(turnRestrictionEnc, artificialEdgeState, viaEdge);</span>
<span class="fc" id="L99">                    artificialEdgeKey = artificialEdgeState.getEdgeKey();</span>
<span class="fc bfc" id="L100" title="All 2 branches covered.">                    if (baseGraph.getEdgeIteratorStateForKey(viaEdgeKey).get(REVERSE_STATE))</span>
<span class="fc" id="L101">                        artificialEdgeKey = GHUtility.reverseEdgeKey(artificialEdgeKey);</span>
<span class="fc" id="L102">                    artificialEdgeKeysByIncViaPairs.put(key, artificialEdgeKey);</span>
                }
<span class="fc" id="L104">                restriction.actualEdgeKeys.set(j, artificialEdgeKey);</span>
<span class="fc" id="L105">                incomingEdge = GHUtility.getEdgeFromEdgeKey(artificialEdgeKey);</span>
            }
        }
<span class="fc" id="L108">        artificialEdgeKeysByIncViaPairs.forEach((LongIntProcedure) (incViaPair, artificialEdgeKey) -&gt; {</span>
<span class="fc" id="L109">            int incomingEdge = BitUtil.LITTLE.getIntLow(incViaPair);</span>
<span class="fc" id="L110">            int viaEdgeKey = BitUtil.LITTLE.getIntHigh(incViaPair);</span>
<span class="fc" id="L111">            int viaEdge = GHUtility.getEdgeFromEdgeKey(viaEdgeKey);</span>
<span class="fc" id="L112">            int node = baseGraph.getEdgeIteratorStateForKey(viaEdgeKey).getBaseNode();</span>
            // we restrict turning onto the original edge and all artificial edges except the one we created for this in-edge
            // i.e. we force turning onto the artificial edge we created for this in-edge
<span class="fc bfc" id="L115" title="All 2 branches covered.">            for (BooleanEncodedValue turnRestrictionEnc : turnRestrictionEncs)</span>
<span class="fc" id="L116">                restrictTurn(turnRestrictionEnc, incomingEdge, node, viaEdge);</span>
<span class="fc" id="L117">            IntSet artificialEdges = artificialEdgesByEdge.get(viaEdge);</span>
<span class="fc" id="L118">            artificialEdges.forEach((IntProcedure) a -&gt; {</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">                if (a != GHUtility.getEdgeFromEdgeKey(artificialEdgeKey))</span>
<span class="fc bfc" id="L120" title="All 2 branches covered.">                    for (BooleanEncodedValue turnRestrictionEnc : turnRestrictionEncs)</span>
<span class="fc" id="L121">                        restrictTurn(turnRestrictionEnc, incomingEdge, node, a);</span>
<span class="fc" id="L122">            });</span>
<span class="fc" id="L123">        });</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        for (int i = 0; i &lt; internalRestrictions.size(); i++) {</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (encBits.get(i).cardinality() &lt; 1) continue;</span>
<span class="fc" id="L126">            InternalRestriction restriction = internalRestrictions.get(i);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">            if (restriction.getEdgeKeys().size() &lt; 3) {</span>
<span class="fc" id="L128">                IntSet fromEdges = artificialEdgesByEdge.getOrDefault(restriction.getFromEdge(), new IntScatterSet());</span>
<span class="fc" id="L129">                fromEdges.add(restriction.getFromEdge());</span>
<span class="fc" id="L130">                IntSet toEdges = artificialEdgesByEdge.getOrDefault(restriction.getToEdge(), new IntScatterSet());</span>
<span class="fc" id="L131">                toEdges.add(restriction.getToEdge());</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">                for (int j = 0; j &lt; turnRestrictionEncs.size(); j++) {</span>
<span class="fc" id="L133">                    BooleanEncodedValue turnRestrictionEnc = turnRestrictionEncs.get(j);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">                    if (encBits.get(i).get(j)) {</span>
<span class="fc" id="L135">                        fromEdges.forEach((IntProcedure) from -&gt; toEdges.forEach((IntProcedure) to -&gt; {</span>
<span class="fc" id="L136">                            restrictTurn(turnRestrictionEnc, from, restriction.getViaNodes().get(0), to);</span>
<span class="fc" id="L137">                        }));</span>
                    }
                }
<span class="fc" id="L140">            } else {</span>
<span class="fc" id="L141">                int viaEdgeKey = restriction.getActualEdgeKeys().get(restriction.getActualEdgeKeys().size() - 2);</span>
<span class="fc" id="L142">                int viaEdge = GHUtility.getEdgeFromEdgeKey(viaEdgeKey);</span>
<span class="fc" id="L143">                int node = baseGraph.getEdgeIteratorStateForKey(viaEdgeKey).getAdjNode();</span>
                // For via-edge restrictions we deny turning from the from-edge onto the via-edge,
                // but allow turning onto the artificial edge(s) instead (see above). Then we deny
                // turning from the artificial edge onto the to-edge here.
<span class="fc bfc" id="L147" title="All 2 branches covered.">                for (int j = 0; j &lt; turnRestrictionEncs.size(); j++) {</span>
<span class="fc" id="L148">                    BooleanEncodedValue turnRestrictionEnc = turnRestrictionEncs.get(j);</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">                    if (encBits.get(i).get(j)) {</span>
<span class="fc" id="L150">                        restrictTurn(turnRestrictionEnc, viaEdge, node, restriction.getToEdge());</span>
                        // also restrict the turns to the artificial edges corresponding to the to-edge
<span class="fc" id="L152">                        artificialEdgesByEdge.getOrDefault(restriction.getToEdge(), EMPTY_SET).forEach(</span>
<span class="fc" id="L153">                                (IntProcedure) toEdge -&gt; restrictTurn(turnRestrictionEnc, viaEdge, node, toEdge)</span>
                        );
                    }
                }
            }
        }
<span class="fc" id="L159">    }</span>

    private void disableRedundantRestrictions(List&lt;InternalRestriction&gt; restrictions, List&lt;BitSet&gt; encBits) {
<span class="fc bfc" id="L162" title="All 2 branches covered.">        for (int encIdx = 0; encIdx &lt; turnRestrictionEncs.size(); encIdx++) {</span>
            // first we disable all duplicates
<span class="fc" id="L164">            Set&lt;InternalRestriction&gt; uniqueRestrictions = new HashSet&lt;&gt;();</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">            for (int i = 0; i &lt; restrictions.size(); i++) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">                if (!encBits.get(i).get(encIdx))</span>
<span class="fc" id="L167">                    continue;</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">                if (!uniqueRestrictions.add(restrictions.get(i)))</span>
<span class="fc" id="L169">                    encBits.get(i).clear(encIdx);</span>
            }
            // build an index of restrictions to quickly find all restrictions containing a given edge key
<span class="fc" id="L172">            IntObjectScatterMap&lt;List&lt;InternalRestriction&gt;&gt; restrictionsByEdgeKeys = new IntObjectScatterMap&lt;&gt;();</span>
<span class="fc bfc" id="L173" title="All 2 branches covered.">            for (int i = 0; i &lt; restrictions.size(); i++) {</span>
<span class="fc bfc" id="L174" title="All 2 branches covered.">                if (!encBits.get(i).get(encIdx))</span>
<span class="fc" id="L175">                    continue;</span>
<span class="fc" id="L176">                InternalRestriction restriction = restrictions.get(i);</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                for (IntCursor edgeKey : restriction.edgeKeys) {</span>
<span class="fc" id="L178">                    int idx = restrictionsByEdgeKeys.indexOf(edgeKey.value);</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">                    if (idx &lt; 0) {</span>
<span class="fc" id="L180">                        List&lt;InternalRestriction&gt; list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L181">                        list.add(restriction);</span>
<span class="fc" id="L182">                        restrictionsByEdgeKeys.indexInsert(idx, edgeKey.value, list);</span>
<span class="fc" id="L183">                    } else {</span>
<span class="fc" id="L184">                        restrictionsByEdgeKeys.indexGet(idx).add(restriction);</span>
                    }
<span class="fc" id="L186">                }</span>
            }
            // Only keep restrictions that do not contain another restriction. For example, it would be unnecessary to restrict
            // 6-8-2 when 6-8 is restricted already
<span class="fc bfc" id="L190" title="All 2 branches covered.">            for (int i = 0; i &lt; restrictions.size(); i++) {</span>
<span class="fc bfc" id="L191" title="All 2 branches covered.">                if (!encBits.get(i).get(encIdx))</span>
<span class="fc" id="L192">                    continue;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                if (containsAnotherRestriction(restrictions.get(i), restrictionsByEdgeKeys))</span>
<span class="fc" id="L194">                    encBits.get(i).clear(encIdx);</span>
            }
        }
<span class="fc" id="L197">    }</span>

    private boolean containsAnotherRestriction(InternalRestriction restriction, IntObjectMap&lt;List&lt;InternalRestriction&gt;&gt; restrictionsByEdgeKeys) {
<span class="fc bfc" id="L200" title="All 2 branches covered.">        for (IntCursor edgeKey : restriction.edgeKeys) {</span>
<span class="fc" id="L201">            List&lt;InternalRestriction&gt; restrictionsWithThisEdgeKey = restrictionsByEdgeKeys.get(edgeKey.value);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">            for (InternalRestriction r : restrictionsWithThisEdgeKey) {</span>
<span class="fc bfc" id="L203" title="All 2 branches covered.">                if (r == restriction) continue;</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                if (r.equals(restriction))</span>
<span class="nc" id="L205">                    throw new IllegalStateException(&quot;Equal restrictions should have already been filtered out here!&quot;);</span>
<span class="fc bfc" id="L206" title="All 2 branches covered.">                if (isSubsetOf(r.edgeKeys, restriction.edgeKeys))</span>
<span class="fc" id="L207">                    return true;</span>
<span class="fc" id="L208">            }</span>
<span class="fc" id="L209">        }</span>
<span class="fc" id="L210">        return false;</span>
    }

    private static boolean isSubsetOf(IntArrayList candidate, IntArrayList array) {
<span class="fc bfc" id="L214" title="All 2 branches covered.">        if (candidate.size() &gt; array.size())</span>
<span class="fc" id="L215">            return false;</span>
<span class="fc bfc" id="L216" title="All 2 branches covered.">        for (int i = 0; i &lt;= array.size() - candidate.size(); i++) {</span>
<span class="fc" id="L217">            boolean isSubset = true;</span>
<span class="fc bfc" id="L218" title="All 2 branches covered.">            for (int j = 0; j &lt; candidate.size(); j++) {</span>
<span class="fc bfc" id="L219" title="All 2 branches covered.">                if (candidate.get(j) != array.get(i + j)) {</span>
<span class="fc" id="L220">                    isSubset = false;</span>
<span class="fc" id="L221">                    break;</span>
                }
            }
<span class="fc bfc" id="L224" title="All 2 branches covered.">            if (isSubset)</span>
<span class="fc" id="L225">                return true;</span>
        }
<span class="fc" id="L227">        return false;</span>
    }

    private void restrictTurnsBetweenEdges(BooleanEncodedValue turnRestrictionEnc, EdgeIteratorState edgeState, int otherEdge) {
<span class="fc" id="L231">        restrictTurn(turnRestrictionEnc, otherEdge, edgeState.getBaseNode(), edgeState.getEdge());</span>
<span class="fc" id="L232">        restrictTurn(turnRestrictionEnc, edgeState.getEdge(), edgeState.getBaseNode(), otherEdge);</span>
<span class="fc" id="L233">        restrictTurn(turnRestrictionEnc, otherEdge, edgeState.getAdjNode(), edgeState.getEdge());</span>
<span class="fc" id="L234">        restrictTurn(turnRestrictionEnc, edgeState.getEdge(), edgeState.getAdjNode(), otherEdge);</span>
<span class="fc" id="L235">    }</span>

    private InternalRestriction convertToInternal(Restriction restriction) {
<span class="fc" id="L238">        IntArrayList edges = restriction.edges;</span>
<span class="pc bpc" id="L239" title="1 of 2 branches missed.">        if (edges.size() &lt; 2)</span>
<span class="nc" id="L240">            throw new IllegalArgumentException(&quot;Invalid restriction, there must be at least two edges&quot;);</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">        else if (edges.size() == 2) {</span>
<span class="fc" id="L242">            int fromKey = baseGraph.getEdgeIteratorState(edges.get(0), restriction.viaNode).getEdgeKey();</span>
<span class="fc" id="L243">            int toKey = baseGraph.getEdgeIteratorState(edges.get(1), restriction.viaNode).getReverseEdgeKey();</span>
<span class="fc" id="L244">            return new InternalRestriction(IntArrayList.from(restriction.viaNode), IntArrayList.from(fromKey, toKey));</span>
        } else {
<span class="fc" id="L246">            Pair&lt;IntArrayList, IntArrayList&gt; p = findNodesAndEdgeKeys(baseGraph, edges);</span>
<span class="fc" id="L247">            p.first.remove(p.first.size() - 1);</span>
<span class="fc" id="L248">            return new InternalRestriction(p.first, p.second);</span>
        }
    }

    private Pair&lt;IntArrayList, IntArrayList&gt; findNodesAndEdgeKeys(BaseGraph baseGraph, IntArrayList edges) {
        // we get a list of edges and need to find the directions of the edges and the connecting nodes
<span class="fc" id="L254">        List&lt;Pair&lt;IntArrayList, IntArrayList&gt;&gt; solutions = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L255">        findEdgeChain(baseGraph, edges, 0, IntArrayList.from(), IntArrayList.from(), solutions);</span>
<span class="pc bpc" id="L256" title="1 of 2 branches missed.">        if (solutions.isEmpty()) {</span>
<span class="nc" id="L257">            throw new IllegalArgumentException(&quot;Disconnected edges: &quot; + edges + &quot; &quot; + edgesToLocationString(baseGraph, edges));</span>
<span class="pc bpc" id="L258" title="1 of 2 branches missed.">        } else if (solutions.size() &gt; 1) {</span>
<span class="nc" id="L259">            throw new IllegalArgumentException(&quot;Ambiguous edge restriction: &quot; + edges + &quot; &quot; + edgesToLocationString(baseGraph, edges));</span>
        } else {
<span class="fc" id="L261">            return solutions.get(0);</span>
        }
    }

    private static String edgesToLocationString(BaseGraph baseGraph, IntArrayList edges) {
<span class="nc" id="L266">        return Arrays.stream(edges.buffer, 0, edges.size()).mapToObj(e -&gt; baseGraph.getEdgeIteratorState(e, Integer.MIN_VALUE).fetchWayGeometry(FetchMode.ALL))</span>
<span class="nc" id="L267">                .toList().toString();</span>
    }

    private void findEdgeChain(BaseGraph baseGraph, IntArrayList edges, int index, IntArrayList nodes, IntArrayList edgeKeys, List&lt;Pair&lt;IntArrayList, IntArrayList&gt;&gt; solutions) {
<span class="fc bfc" id="L271" title="All 2 branches covered.">        if (index == edges.size()) {</span>
<span class="fc" id="L272">            solutions.add(new Pair&lt;&gt;(new IntArrayList(nodes), new IntArrayList(edgeKeys)));</span>
<span class="fc" id="L273">            return;</span>
        }
<span class="fc" id="L275">        EdgeIteratorState edgeState = baseGraph.getEdgeIteratorState(edges.get(index), Integer.MIN_VALUE);</span>
<span class="fc bfc" id="L276" title="All 4 branches covered.">        if (index == 0 || edgeState.getBaseNode() == nodes.get(nodes.size() - 1)) {</span>
<span class="fc" id="L277">            nodes.add(edgeState.getAdjNode());</span>
<span class="fc" id="L278">            edgeKeys.add(edgeState.getEdgeKey());</span>
<span class="fc" id="L279">            findEdgeChain(baseGraph, edges, index + 1, nodes, edgeKeys, solutions);</span>
<span class="fc" id="L280">            nodes.elementsCount--;</span>
<span class="fc" id="L281">            edgeKeys.elementsCount--;</span>
        }
<span class="fc bfc" id="L283" title="All 4 branches covered.">        if (index == 0 || edgeState.getAdjNode() == nodes.get(nodes.size() - 1)) {</span>
<span class="fc" id="L284">            nodes.add(edgeState.getBaseNode());</span>
<span class="fc" id="L285">            edgeKeys.add(edgeState.getReverseEdgeKey());</span>
<span class="fc" id="L286">            findEdgeChain(baseGraph, edges, index + 1, nodes, edgeKeys, solutions);</span>
<span class="fc" id="L287">            nodes.elementsCount--;</span>
<span class="fc" id="L288">            edgeKeys.elementsCount--;</span>
        }
<span class="fc" id="L290">    }</span>

    private void restrictTurn(BooleanEncodedValue turnRestrictionEnc, int fromEdge, int viaNode, int toEdge) {
<span class="pc bpc" id="L293" title="3 of 6 branches missed.">        if (fromEdge &lt; 0 || toEdge &lt; 0 || viaNode &lt; 0)</span>
<span class="nc" id="L294">            throw new IllegalArgumentException(&quot;from/toEdge and viaNode must be &gt;= 0&quot;);</span>
<span class="fc" id="L295">        baseGraph.getTurnCostStorage().set(turnRestrictionEnc, fromEdge, viaNode, toEdge, true);</span>
<span class="fc" id="L296">    }</span>

    public static BitSet copyEncBits(BitSet encBits) {
<span class="fc" id="L299">        return new BitSet(Arrays.copyOf(encBits.bits, encBits.bits.length), encBits.wlen);</span>
    }

    public static class Restriction {
        public final IntArrayList edges;
        private final int viaNode;

<span class="fc" id="L306">        private Restriction(IntArrayList edges, int viaNode) {</span>
<span class="fc" id="L307">            this.edges = edges;</span>
<span class="fc" id="L308">            this.viaNode = viaNode;</span>
<span class="fc" id="L309">        }</span>

        @Override
        public String toString() {
<span class="nc" id="L313">            return &quot;edges: &quot; + edges.toString() + &quot;, viaNode: &quot; + viaNode;</span>
        }
    }

    private static class InternalRestriction {
        private final IntArrayList viaNodes;
        private final IntArrayList edgeKeys;
        private final IntArrayList actualEdgeKeys;

<span class="fc" id="L322">        public InternalRestriction(IntArrayList viaNodes, IntArrayList edgeKeys) {</span>
<span class="fc" id="L323">            this.edgeKeys = edgeKeys;</span>
<span class="fc" id="L324">            this.viaNodes = viaNodes;</span>
<span class="fc" id="L325">            this.actualEdgeKeys = ArrayUtil.constant(edgeKeys.size(), -1);</span>
<span class="fc" id="L326">            this.actualEdgeKeys.set(0, edgeKeys.get(0));</span>
<span class="fc" id="L327">            this.actualEdgeKeys.set(edgeKeys.size() - 1, edgeKeys.get(edgeKeys.size() - 1));</span>
<span class="fc" id="L328">        }</span>

        public IntArrayList getViaNodes() {
<span class="fc" id="L331">            return viaNodes;</span>
        }

        public int getFromEdge() {
<span class="fc" id="L335">            return GHUtility.getEdgeFromEdgeKey(edgeKeys.get(0));</span>
        }

        public IntArrayList getEdgeKeys() {
<span class="fc" id="L339">            return edgeKeys;</span>
        }

        public IntArrayList getActualEdgeKeys() {
<span class="fc" id="L343">            return actualEdgeKeys;</span>
        }

        public int getToEdge() {
<span class="fc" id="L347">            return GHUtility.getEdgeFromEdgeKey(edgeKeys.get(edgeKeys.size() - 1));</span>
        }

        @Override
        public int hashCode() {
<span class="fc" id="L352">            return 31 * viaNodes.hashCode() + edgeKeys.hashCode();</span>
        }

        @Override
        public boolean equals(Object obj) {
            // this is actually needed, because we build a Set of InternalRestrictions to remove duplicates
            // no need to compare the actualEdgeKeys
<span class="pc bpc" id="L359" title="1 of 2 branches missed.">            if (!(obj instanceof InternalRestriction)) return false;</span>
<span class="fc bfc" id="L360" title="All 4 branches covered.">            return ((InternalRestriction) obj).viaNodes.equals(viaNodes) &amp;&amp; ((InternalRestriction) obj).edgeKeys.equals(edgeKeys);</span>
        }

        @Override
        public String toString() {
<span class="nc" id="L365">            StringBuilder result = new StringBuilder();</span>
<span class="nc bnc" id="L366" title="All 2 branches missed.">            for (int i = 0; i &lt; viaNodes.size(); i++)</span>
<span class="nc" id="L367">                result.append(GHUtility.getEdgeFromEdgeKey(edgeKeys.get(i))).append(&quot;-(&quot;).append(viaNodes.get(i)).append(&quot;)-&quot;);</span>
<span class="nc" id="L368">            return result + &quot;&quot; + GHUtility.getEdgeFromEdgeKey(edgeKeys.get(edgeKeys.size() - 1));</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>