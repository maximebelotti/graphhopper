<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>OSMTemporalAccessParser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.util.parsers</a> &gt; <span class="el_source">OSMTemporalAccessParser.java</span></div><h1>OSMTemporalAccessParser.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.graphhopper.routing.util.parsers;

import com.graphhopper.reader.ReaderWay;
import com.graphhopper.reader.osm.conditional.ConditionalValueParser;
import com.graphhopper.reader.osm.conditional.DateRangeParser;
import com.graphhopper.routing.ev.EdgeIntAccess;
import com.graphhopper.storage.IntsRef;
import com.graphhopper.util.Helper;

import java.text.ParseException;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * This parser fills the different XYTemporalAccess enums from the OSM conditional
 * restrictions based on the specified dateRangeParserDate. 'Temporal' means that both, temporary
 * and seasonal restrictions will be considered. Node tags will be ignored for now.
 */
public class OSMTemporalAccessParser implements TagParser {

    private final Collection&lt;String&gt; conditionals;
    private final Setter restrictionSetter;
    private final DateRangeParser parser;

    @FunctionalInterface
    public interface Setter {
        void setBoolean(int edgeId, EdgeIntAccess edgeIntAccess, boolean b);
    }

<span class="fc" id="L50">    public OSMTemporalAccessParser(Collection&lt;String&gt; conditionals, Setter restrictionSetter, String dateRangeParserDate) {</span>
<span class="fc" id="L51">        this.conditionals = conditionals;</span>
<span class="fc" id="L52">        this.restrictionSetter = restrictionSetter;</span>
<span class="pc bpc" id="L53" title="1 of 2 branches missed.">        if (dateRangeParserDate.isEmpty())</span>
<span class="nc" id="L54">            dateRangeParserDate = Helper.createFormatter(&quot;yyyy-MM-dd&quot;).format(new Date().getTime());</span>

<span class="fc" id="L56">        this.parser = DateRangeParser.createInstance(dateRangeParserDate);</span>
<span class="fc" id="L57">    }</span>

    @Override
    public void handleWayTags(int edgeId, EdgeIntAccess edgeIntAccess, ReaderWay way, IntsRef relationFlags) {
        // TODO for now the node tag overhead is not worth the effort due to very few data points
        // List&lt;Map&lt;String, Object&gt;&gt; nodeTags = way.getTag(&quot;node_tags&quot;, null);

<span class="fc" id="L64">        Boolean b = getTemporaryAccess(way.getTags());</span>
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (b != null)</span>
<span class="fc" id="L66">            restrictionSetter.setBoolean(edgeId, edgeIntAccess, b);</span>
<span class="fc" id="L67">    }</span>

    public Boolean getTemporaryAccess(Map&lt;String, Object&gt; tags) {
<span class="fc bfc" id="L70" title="All 2 branches covered.">        for (Map.Entry&lt;String, Object&gt; entry : tags.entrySet()) {</span>
<span class="fc bfc" id="L71" title="All 2 branches covered.">            if (!conditionals.contains(entry.getKey())) continue;</span>

<span class="fc" id="L73">            String value = (String) entry.getValue();</span>
<span class="fc" id="L74">            String[] strs = value.split(&quot;@&quot;);</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">            if (strs.length == 2) {</span>
<span class="fc" id="L76">                Boolean inRange = isInRange(parser, strs[1].trim());</span>
<span class="fc bfc" id="L77" title="All 2 branches covered.">                if (inRange != null) {</span>
<span class="fc bfc" id="L78" title="All 4 branches covered.">                    if (strs[0].trim().equals(&quot;no&quot;)) return !inRange;</span>
<span class="pc bpc" id="L79" title="1 of 2 branches missed.">                    if (strs[0].trim().equals(&quot;yes&quot;)) return inRange;</span>
                }
            }
<span class="fc" id="L82">        }</span>
<span class="fc" id="L83">        return null;</span>
    }

    private static Boolean isInRange(final DateRangeParser parser, final String value) {
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (value.isEmpty())</span>
<span class="nc" id="L88">            return null;</span>

<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (value.contains(&quot;;&quot;))</span>
<span class="nc" id="L91">            return null;</span>

<span class="fc" id="L93">        String conditionalValue = value.replace('(', ' ').replace(')', ' ').trim();</span>
        try {
<span class="fc" id="L95">            ConditionalValueParser.ConditionState res = parser.checkCondition(conditionalValue);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">            if (res.isValid())</span>
<span class="fc" id="L97">                return res.isCheckPassed();</span>
<span class="fc" id="L98">        } catch (ParseException ex) {</span>
<span class="fc" id="L99">        }</span>
<span class="fc" id="L100">        return null;</span>
    }

    /**
     * This method checks the conditional restrictions starting from firstIndex and returns
     * true if the access value is in the &quot;accepted&quot; collection AND the conditional value describes
     * a time (e.g. date, time or interval).
     */
    public static boolean hasPermissiveTemporalRestriction(ReaderWay way, int firstIndex,
                                                           List&lt;String&gt; restrictionKeys, Collection&lt;String&gt; accepted) {
<span class="fc bfc" id="L110" title="All 2 branches covered.">        for (int i = firstIndex; i &gt;= 0; i--) {</span>
<span class="fc" id="L111">            String value = way.getTag(restrictionKeys.get(i) + &quot;:conditional&quot;);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            if (acceptedAndInRange(value, accepted)) return true;</span>
        }
<span class="fc" id="L114">        return false;</span>
    }

    private static boolean acceptedAndInRange(String value, Collection&lt;String&gt; accepted) {
<span class="fc bfc" id="L118" title="All 2 branches covered.">        if (value == null) return false;</span>
<span class="fc" id="L119">        String[] strs = value.split(&quot;@&quot;);</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (strs.length == 2)</span>
            try {
<span class="fc" id="L122">                String conditionalValue = strs[1].replace('(', ' ').replace(')', ' ').trim();</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">                return accepted.contains(strs[0].trim()) &amp;&amp;</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                        (strs[1].contains(&quot;:&quot;) // time</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">                                || DateRangeParser.getRange(conditionalValue    ) != null // date</span>
                        );
<span class="fc" id="L127">            } catch (ParseException ex) {</span>
            }
<span class="fc" id="L129">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>