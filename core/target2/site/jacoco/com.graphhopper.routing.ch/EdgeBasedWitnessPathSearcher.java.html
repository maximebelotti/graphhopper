<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>EdgeBasedWitnessPathSearcher.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.ch</a> &gt; <span class="el_source">EdgeBasedWitnessPathSearcher.java</span></div><h1>EdgeBasedWitnessPathSearcher.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.graphhopper.routing.ch;

import com.carrotsearch.hppc.IntArrayList;
import com.graphhopper.apache.commons.collections.IntFloatBinaryHeap;
import com.graphhopper.util.GHUtility;

import java.util.Arrays;
import java.util.Locale;

import static com.graphhopper.util.Helper.nf;

/**
 * Helper class used to perform local witness path searches for graph preparation in edge-based Contraction Hierarchies.
 * &lt;p&gt;
 * (source edge) -- s -- x -- t -- (target edge)
 * Let x be a node to be contracted (the 'center node') and s and t neighboring un-contracted nodes of x that are
 * directly connected with x (via a normal edge or a shortcut). This class is used to find out whether a path between a
 * given source edge incoming to s and a given target edge outgoing from t exists with a given maximum weight. The
 * weights of the source and target edges are not counted in, but the turn costs from the source edge to s-&gt;x and from
 * x-&gt;t to the target edge are. We also distinguish whether this path is a 'bridge-path' or not:
 * &lt;p&gt;
 * 1) The path only consists of one edge from s to x, an arbitrary number of loops at x, and one edge from x to t.
 * This is called a 'bridge-path' here.
 * 2) The path includes an edge from s to a node other than x or an edge from another node than x to t.
 * This is called a 'witness-path'. Note that a witness path can still include x! This is because if a witness includes
 * x we still do not need to include a shortcut because the path contains another (smaller) shortcut in this case.
 * &lt;p&gt;
 * To find the optimal path an edge-based unidirectional Dijkstra algorithm is used that takes into account turn-costs.
 * The search is initialized for a given source edge key and node to be contracted x. Subsequent searches for different
 * target edges will keep on building the shortest path tree from previous searches. For the performance of edge-based
 * CH graph preparation it is crucial to limit the local witness path searches as much as possible.
 *
 * @author easbar
 */
public class EdgeBasedWitnessPathSearcher {
    private static final int NO_NODE = -1;
    private static final double MAX_ZERO_WEIGHT_LOOP = 1.e-3;

    private final CHPreparationGraph prepareGraph;
    private PrepareGraphEdgeExplorer outEdgeExplorer;
    private PrepareGraphOrigEdgeExplorer origInEdgeExplorer;

    private int sourceNode;
    private int centerNode;

    // various counters
    private int numPolls;
    private int numUpdates;

    // data structures used to build the shortest path tree
    // we allocate memory for all possible edge keys and keep track which ones have been discovered so far
    private double[] weights;
    private int[] parents;
    private int[] adjNodesAndIsPathToCenters;
    private IntArrayList changedEdgeKeys;
    private IntFloatBinaryHeap dijkstraHeap;

    // statistics to analyze performance
    private Stats stats;

<span class="fc" id="L78">    public EdgeBasedWitnessPathSearcher(CHPreparationGraph prepareGraph) {</span>
<span class="fc" id="L79">        this.prepareGraph = prepareGraph;</span>

<span class="fc" id="L81">        outEdgeExplorer = prepareGraph.createOutEdgeExplorer();</span>
<span class="fc" id="L82">        origInEdgeExplorer = prepareGraph.createInOrigEdgeExplorer();</span>

<span class="fc" id="L84">        initStorage(2 * prepareGraph.getOriginalEdges());</span>
<span class="fc" id="L85">        initCollections();</span>
<span class="fc" id="L86">    }</span>

    /**
     * Deletes the shortest path tree that has been found so far and initializes a new witness path search for a given
     * node to be contracted and source edge key.
     *
     * @param sourceEdgeKey the key of the original edge incoming to s from which the search starts
     * @param sourceNode    the neighbor node from which the search starts (s)
     * @param centerNode    the node to be contracted (x)
     */
    public void initSearch(int sourceEdgeKey, int sourceNode, int centerNode, Stats stats) {
<span class="fc" id="L97">        this.stats = stats;</span>
<span class="fc" id="L98">        stats.numTrees++;</span>
<span class="fc" id="L99">        this.sourceNode = sourceNode;</span>
<span class="fc" id="L100">        this.centerNode = centerNode;</span>

        // set start entry
<span class="fc" id="L103">        weights[sourceEdgeKey] = 0;</span>
<span class="fc" id="L104">        parents[sourceEdgeKey] = -1;</span>
<span class="fc" id="L105">        setAdjNodeAndPathToCenter(sourceEdgeKey, sourceNode, true);</span>
<span class="fc" id="L106">        changedEdgeKeys.add(sourceEdgeKey);</span>
<span class="fc" id="L107">        dijkstraHeap.insert(0, sourceEdgeKey);</span>
<span class="fc" id="L108">    }</span>

    /**
     * Runs a witness path search for a given target edge key. Results of previous searches (the shortest path tree) are
     * reused and the previous search is extended if necessary. Note that you need to call
     * {@link #initSearch(int, int, int, Stats)} before calling this method to initialize the search.
     *
     * @param targetNode     the neighbor node that should be reached by the path (t)
     * @param targetEdgeKey  the original edge key outgoing from t where the search ends
     * @param acceptedWeight Once we find a path with a weight smaller or equal to this we return the weight. The
     *                       returned weight might be larger than the weight of the real shortest path. If there is
     *                       no path with weight smaller than or equal to this we stop the search and return the weight
     *                       of the best path found so far.
     * @return the weight of the found path or {@link Double#POSITIVE_INFINITY} if no path was found
     */
    public double runSearch(int targetNode, int targetEdgeKey, double acceptedWeight, int maxPolls) {
<span class="fc" id="L124">        stats.numSearches++;</span>
        // first we check if we can already reach the target edge from the shortest path tree we discovered so far
<span class="fc" id="L126">        PrepareGraphOrigEdgeIterator inIter = origInEdgeExplorer.setBaseNode(targetNode);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        while (inIter.next()) {</span>
<span class="fc" id="L128">            final int edgeKey = GHUtility.reverseEdgeKey(inIter.getOrigEdgeKeyLast());</span>
<span class="fc bfc" id="L129" title="All 2 branches covered.">            if (weights[edgeKey] == Double.POSITIVE_INFINITY)</span>
<span class="fc" id="L130">                continue;</span>
<span class="fc" id="L131">            double weight = weights[edgeKey] + calcTurnWeight(edgeKey, targetNode, targetEdgeKey);</span>
<span class="fc bfc" id="L132" title="All 8 branches covered.">            if (weight &lt; acceptedWeight || (weight == acceptedWeight &amp;&amp; (parents[edgeKey] &lt; 0 || !isPathToCenter(parents[edgeKey]))))</span>
<span class="fc" id="L133">                return weight;</span>
<span class="fc" id="L134">        }</span>

        // run the search
<span class="fc bfc" id="L137" title="All 4 branches covered.">        while (!dijkstraHeap.isEmpty() &amp;&amp; numPolls &lt; maxPolls &amp;&amp;</span>
                // we *could* use dijkstraHeap.peekKey() instead, but since it is cast to float this might be smaller than
                // the actual weight in which case the search might continue and find a false witness path when there is
                // an adjacent zero weight edge *and* u-turn costs are zero. we could check this explicitly somewhere,,
                // but we just use the exact weight here instead. #2564
<span class="fc bfc" id="L142" title="All 2 branches covered.">                weights[dijkstraHeap.peekElement()] &lt; acceptedWeight</span>
        ) {
<span class="fc" id="L144">            int currKey = dijkstraHeap.poll();</span>
<span class="fc" id="L145">            numPolls++;</span>
<span class="fc" id="L146">            final int currNode = getAdjNode(currKey);</span>
<span class="fc" id="L147">            PrepareGraphEdgeIterator iter = outEdgeExplorer.setBaseNode(currNode);</span>
<span class="fc" id="L148">            double foundWeight = Double.POSITIVE_INFINITY;</span>
<span class="fc bfc" id="L149" title="All 2 branches covered.">            while (iter.next()) {</span>
                // in a few very special cases this is needed to prevent paths that start with a zero weight loop from
                // being recognized as witnesses when there are double zero weight loops at the source node
<span class="pc bpc" id="L152" title="1 of 6 branches missed.">                if (currNode == sourceNode &amp;&amp; iter.getAdjNode() == sourceNode &amp;&amp; iter.getWeight() &lt; MAX_ZERO_WEIGHT_LOOP)</span>
<span class="nc" id="L153">                    continue;</span>
<span class="fc" id="L154">                final double weight = weights[currKey] + calcTurnWeight(currKey, currNode, iter.getOrigEdgeKeyFirst()) + iter.getWeight();</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">                if (Double.isInfinite(weight))</span>
<span class="fc" id="L156">                    continue;</span>
<span class="fc" id="L157">                final int key = iter.getOrigEdgeKeyLast();</span>
<span class="fc bfc" id="L158" title="All 4 branches covered.">                final boolean isPathToCenter = isPathToCenter(currKey) &amp;&amp; iter.getAdjNode() == centerNode;</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">                if (weights[key] == Double.POSITIVE_INFINITY) {</span>
<span class="fc" id="L160">                    weights[key] = weight;</span>
<span class="fc" id="L161">                    parents[key] = currKey;</span>
<span class="fc" id="L162">                    setAdjNodeAndPathToCenter(key, iter.getAdjNode(), isPathToCenter);</span>
<span class="fc" id="L163">                    changedEdgeKeys.add(key);</span>
<span class="fc" id="L164">                    dijkstraHeap.insert(weight, key);</span>
<span class="fc bfc" id="L165" title="All 6 branches covered.">                    if (iter.getAdjNode() == targetNode &amp;&amp; (!isPathToCenter(currKey) || parents[currKey] &lt; 0))</span>
<span class="fc" id="L166">                        foundWeight = Math.min(foundWeight, weight + calcTurnWeight(key, targetNode, targetEdgeKey));</span>
<span class="fc bfc" id="L167" title="All 4 branches covered.">                } else if (weight &lt; weights[key]</span>
                        // if weights are equal make sure we prefer witness paths over bridge paths
<span class="fc bfc" id="L169" title="All 2 branches covered.">                        || (weight == weights[key] &amp;&amp; !isPathToCenter(currKey))) {</span>
<span class="fc" id="L170">                    numUpdates++;</span>
<span class="fc" id="L171">                    weights[key] = weight;</span>
<span class="fc" id="L172">                    parents[key] = currKey;</span>
<span class="fc" id="L173">                    setAdjNodeAndPathToCenter(key, iter.getAdjNode(), isPathToCenter);</span>
<span class="fc" id="L174">                    dijkstraHeap.update(weight, key);</span>
<span class="fc bfc" id="L175" title="All 6 branches covered.">                    if (iter.getAdjNode() == targetNode &amp;&amp; (!isPathToCenter(currKey) || parents[currKey] &lt; 0))</span>
<span class="fc" id="L176">                        foundWeight = Math.min(foundWeight, weight + calcTurnWeight(key, targetNode, targetEdgeKey));</span>
                }
<span class="fc" id="L178">            }</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            if (foundWeight &lt;= acceptedWeight)</span>
                // note that we have to finish the iteration for the current node, otherwise we'll never check the
                // remaining edges again
<span class="fc" id="L182">                return foundWeight;</span>
<span class="fc" id="L183">        }</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">        if (numPolls == maxPolls)</span>
<span class="fc" id="L185">            stats.numCapped++;</span>
<span class="fc" id="L186">        return Double.POSITIVE_INFINITY;</span>
    }

    public void finishSearch() {

        // update stats using values of last search
<span class="fc" id="L192">        stats.numPolls += numPolls;</span>
<span class="fc" id="L193">        stats.maxPolls = Math.max(stats.maxPolls, numPolls);</span>
<span class="fc" id="L194">        stats.numExplored += changedEdgeKeys.size();</span>
<span class="fc" id="L195">        stats.maxExplored = Math.max(stats.maxExplored, changedEdgeKeys.size());</span>
<span class="fc" id="L196">        stats.numUpdates += numUpdates;</span>
<span class="fc" id="L197">        stats.maxUpdates = Math.max(stats.maxUpdates, numUpdates);</span>
<span class="fc" id="L198">        reset();</span>
<span class="fc" id="L199">    }</span>

    private void setAdjNodeAndPathToCenter(int key, int adjNode, boolean isPathToCenter) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        adjNodesAndIsPathToCenters[key] = (adjNode &lt;&lt; 1) + (isPathToCenter ? 1 : 0);</span>
<span class="fc" id="L203">    }</span>

    private int getAdjNode(int key) {
<span class="fc" id="L206">        return (adjNodesAndIsPathToCenters[key] &gt;&gt; 1);</span>
    }

    private boolean isPathToCenter(int key) {
<span class="fc bfc" id="L210" title="All 2 branches covered.">        return (adjNodesAndIsPathToCenters[key] &amp; 0b01) == 0b01;</span>
    }

    public void close() {
<span class="fc" id="L214">        prepareGraph.close();</span>
<span class="fc" id="L215">        outEdgeExplorer = null;</span>
<span class="fc" id="L216">        origInEdgeExplorer = null;</span>
<span class="fc" id="L217">        weights = null;</span>
<span class="fc" id="L218">        parents = null;</span>
<span class="fc" id="L219">        adjNodesAndIsPathToCenters = null;</span>
<span class="fc" id="L220">        changedEdgeKeys.release();</span>
<span class="fc" id="L221">        dijkstraHeap = null;</span>
<span class="fc" id="L222">    }</span>

    private void initStorage(int numEntries) {
<span class="fc" id="L225">        weights = new double[numEntries];</span>
<span class="fc" id="L226">        Arrays.fill(weights, Double.POSITIVE_INFINITY);</span>

<span class="fc" id="L228">        parents = new int[numEntries];</span>
<span class="fc" id="L229">        Arrays.fill(parents, NO_NODE);</span>

<span class="fc" id="L231">        adjNodesAndIsPathToCenters = new int[numEntries];</span>
        // need bit shift, see getAdjNode(int)
<span class="fc" id="L233">        Arrays.fill(adjNodesAndIsPathToCenters, NO_NODE &lt;&lt; 1);</span>
<span class="fc" id="L234">    }</span>

    private void initCollections() {
<span class="fc" id="L237">        changedEdgeKeys = new IntArrayList(1000);</span>
<span class="fc" id="L238">        dijkstraHeap = new IntFloatBinaryHeap(1000);</span>
<span class="fc" id="L239">    }</span>

    private void reset() {
<span class="fc" id="L242">        numPolls = 0;</span>
<span class="fc" id="L243">        numUpdates = 0;</span>
<span class="fc" id="L244">        resetShortestPathTree();</span>
<span class="fc" id="L245">    }</span>

    private void resetShortestPathTree() {
<span class="fc bfc" id="L248" title="All 2 branches covered.">        for (int i = 0; i &lt; changedEdgeKeys.size(); ++i)</span>
<span class="fc" id="L249">            resetEntry(changedEdgeKeys.get(i));</span>
<span class="fc" id="L250">        changedEdgeKeys.elementsCount = 0;</span>
<span class="fc" id="L251">        dijkstraHeap.clear();</span>
<span class="fc" id="L252">    }</span>

    private void resetEntry(int key) {
<span class="fc" id="L255">        weights[key] = Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L256">        parents[key] = NO_NODE;</span>
<span class="fc" id="L257">        setAdjNodeAndPathToCenter(key, NO_NODE, false);</span>
<span class="fc" id="L258">    }</span>

    private double calcTurnWeight(int inEdgeKey, int viaNode, int outEdgeKey) {
<span class="fc" id="L261">        return prepareGraph.getTurnWeight(inEdgeKey, viaNode, outEdgeKey);</span>
    }

<span class="fc" id="L264">    static class Stats {</span>
        long numTrees;
        long numSearches;
        long numPolls;
        long maxPolls;
        long numExplored;
        long maxExplored;
        long numUpdates;
        long maxUpdates;
        long numCapped;

        @Override
        public String toString() {
<span class="fc" id="L277">            return String.format(Locale.ROOT,</span>
                    &quot;trees: %12s, searches: %15s, capped: %12s (%5.2f%%), polled: avg %s max %6d, explored: avg %s max %6d, updated: avg %s max %6d&quot;,
<span class="fc" id="L279">                    nf(numTrees),</span>
<span class="fc" id="L280">                    nf(numSearches),</span>
<span class="fc" id="L281">                    nf(numCapped),</span>
<span class="fc" id="L282">                    100 * (double) numCapped / numSearches,</span>
<span class="fc" id="L283">                    quotient(numPolls, numTrees),</span>
<span class="fc" id="L284">                    maxPolls,</span>
<span class="fc" id="L285">                    quotient(numExplored, numTrees),</span>
<span class="fc" id="L286">                    maxExplored,</span>
<span class="fc" id="L287">                    quotient(numUpdates, numTrees),</span>
<span class="fc" id="L288">                    maxUpdates</span>
            );
        }

        private String quotient(long a, long b) {
<span class="fc bfc" id="L293" title="All 2 branches covered.">            return b == 0 ? &quot;NaN&quot; : String.format(Locale.ROOT, &quot;%5.1f&quot;, a / ((double) b));</span>
        }

    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>