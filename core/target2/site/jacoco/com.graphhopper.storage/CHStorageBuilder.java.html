<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CHStorageBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.storage</a> &gt; <span class="el_source">CHStorageBuilder.java</span></div><h1>CHStorageBuilder.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.graphhopper.storage;

import java.util.function.IntUnaryOperator;

/**
 * Builds a valid {@link CHStorage}, i.e. makes sure that
 * - a valid level is already set for nodeA/B when adding a shortcut nodeA-nodeB
 * - level(nodeB) &gt; level(nodeA) for all added shortcuts, unless nodeA == nodeB, then level(nodeA) == level(nodeB)
 * - shortcuts are added such that they are sorted by level(nodeA)
 * - the 'last shortcut' for node n points to the last shortcut for which nodeA == n
 */
public class CHStorageBuilder {
    private final CHStorage storage;

<span class="fc" id="L33">    public CHStorageBuilder(CHStorage chStorage) {</span>
        // todo: maybe CHStorageBuilder should create CHStorage, not receive it here
<span class="fc" id="L35">        this.storage = chStorage;</span>
<span class="fc" id="L36">    }</span>

    public void setLevel(int node, int level) {
<span class="fc" id="L39">        storage.setLevel(storage.toNodePointer(node), level);</span>
<span class="fc" id="L40">    }</span>

    public void setLevelForAllNodes(int level) {
<span class="fc bfc" id="L43" title="All 2 branches covered.">        for (int node = 0; node &lt; storage.getNodes(); node++)</span>
<span class="fc" id="L44">            setLevel(node, level);</span>
<span class="fc" id="L45">    }</span>

    public void setIdentityLevels() {
<span class="fc bfc" id="L48" title="All 2 branches covered.">        for (int node = 0; node &lt; storage.getNodes(); node++)</span>
<span class="fc" id="L49">            setLevel(node, node);</span>
<span class="fc" id="L50">    }</span>

    public int addShortcutNodeBased(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2) {
<span class="fc" id="L53">        checkNewShortcut(a, b);</span>
<span class="fc" id="L54">        int shortcut = storage.shortcutNodeBased(a, b, accessFlags, weight, skippedEdge1, skippedEdge2);</span>
        // we keep track of the last shortcut for each node (-1 if there are no shortcuts), but
        // we do not register the shortcut at node b, because b is the higher level node (so no need to 'see' the lower
        // level node a)
<span class="fc" id="L58">        setLastShortcut(a, shortcut);</span>
<span class="fc" id="L59">        return shortcut;</span>
    }

    /**
     * @param origKeyFirst The first original edge key that is skipped by this shortcut *in the direction of the shortcut*.
     *                     This definition assumes that edge-based shortcuts are one-directional, and they are.
     *                     For example for the following shortcut edge from x to y: x-&gt;u-&gt;v-&gt;w-&gt;y ,
     *                     which skips the shortcuts x-&gt;v and v-&gt;y the first original edge key would be the one of the edge x-&gt;u
     * @param origKeyLast  like origKeyFirst, but the last orig edge key, i.e. the key of w-&gt;y in above example
     */
    public int addShortcutEdgeBased(int a, int b, int accessFlags, double weight, int skippedEdge1, int skippedEdge2,
                                    int origKeyFirst, int origKeyLast) {
<span class="fc" id="L71">        checkNewShortcut(a, b);</span>
<span class="fc" id="L72">        int shortcut = storage.shortcutEdgeBased(a, b, accessFlags, weight, skippedEdge1, skippedEdge2, origKeyFirst, origKeyLast);</span>
<span class="fc" id="L73">        setLastShortcut(a, shortcut);</span>
<span class="fc" id="L74">        return shortcut;</span>
    }

    public void replaceSkippedEdges(IntUnaryOperator mapping) {
<span class="fc bfc" id="L78" title="All 2 branches covered.">        for (int i = 0; i &lt; storage.getShortcuts(); ++i) {</span>
<span class="fc" id="L79">            long shortcutPointer = storage.toShortcutPointer(i);</span>
<span class="fc" id="L80">            int skip1 = storage.getSkippedEdge1(shortcutPointer);</span>
<span class="fc" id="L81">            int skip2 = storage.getSkippedEdge2(shortcutPointer);</span>
<span class="fc" id="L82">            storage.setSkippedEdges(shortcutPointer, mapping.applyAsInt(skip1), mapping.applyAsInt(skip2));</span>
        }
<span class="fc" id="L84">    }</span>

    private void checkNewShortcut(int a, int b) {
<span class="fc" id="L87">        checkNodeId(a);</span>
<span class="fc" id="L88">        checkNodeId(b);</span>
<span class="pc bpc" id="L89" title="2 of 4 branches missed.">        if (getLevel(a) &gt;= storage.getNodes() || getLevel(a) &lt; 0)</span>
<span class="nc" id="L90">            throw new IllegalArgumentException(&quot;Invalid level for node &quot; + a + &quot;: &quot; + getLevel(a) + &quot;. Node a must&quot; +</span>
                    &quot; be assigned a valid level before we add shortcuts a-&gt;b or a&lt;-b&quot;);
<span class="fc bfc" id="L92" title="All 4 branches covered.">        if (a != b &amp;&amp; getLevel(a) == getLevel(b))</span>
<span class="fc" id="L93">            throw new IllegalArgumentException(&quot;Different nodes must not have the same level, got levels &quot; + getLevel(a)</span>
<span class="fc" id="L94">                    + &quot; and &quot; + getLevel(b) + &quot; for nodes &quot; + a + &quot; and &quot; + b);</span>
<span class="pc bpc" id="L95" title="1 of 4 branches missed.">        if (a != b &amp;&amp; getLevel(a) &gt; getLevel(b))</span>
<span class="nc" id="L96">            throw new IllegalArgumentException(&quot;The level of nodeA must be smaller than the level of nodeB, but got: &quot; +</span>
<span class="nc" id="L97">                    getLevel(a) + &quot; and &quot; + getLevel(b) + &quot;. When inserting shortcut: &quot; + a + &quot;-&quot; + b);</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">        if (storage.getShortcuts() &gt; 0) {</span>
<span class="fc" id="L99">            int prevNodeA = storage.getNodeA(storage.toShortcutPointer(storage.getShortcuts() - 1));</span>
<span class="fc" id="L100">            int prevLevelA = getLevel(prevNodeA);</span>
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">            if (getLevel(a) &lt; prevLevelA) {</span>
<span class="nc" id="L102">                throw new IllegalArgumentException(&quot;Invalid level for node &quot; + a + &quot;: &quot; + getLevel(a) + &quot;. The level &quot; +</span>
                        &quot;must be equal to or larger than the lower level node of the previous shortcut (node: &quot; + prevNodeA +
                        &quot;, level: &quot; + prevLevelA + &quot;)&quot;);
            }
        }
<span class="fc" id="L107">    }</span>

    private void setLastShortcut(int node, int shortcut) {
<span class="fc" id="L110">        storage.setLastShortcut(storage.toNodePointer(node), shortcut);</span>
<span class="fc" id="L111">    }</span>

    private int getLevel(int node) {
<span class="fc" id="L114">        checkNodeId(node);</span>
<span class="fc" id="L115">        return storage.getLevel(storage.toNodePointer(node));</span>
    }

    private void checkNodeId(int node) {
<span class="pc bpc" id="L119" title="2 of 4 branches missed.">        if (node &gt;= storage.getNodes() || node &lt; 0)</span>
<span class="nc" id="L120">            throw new IllegalArgumentException(&quot;node &quot; + node + &quot; is invalid. Not in [0,&quot; + storage.getNodes() + &quot;)&quot;);</span>
<span class="fc" id="L121">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>