<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CHStorage.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.storage</a> &gt; <span class="el_source">CHStorage.java</span></div><h1>CHStorage.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.graphhopper.storage;

import com.graphhopper.routing.ch.NodeOrderingProvider;
import com.graphhopper.routing.ch.PrepareEncoder;
import com.graphhopper.util.Constants;
import com.graphhopper.util.GHUtility;
import com.graphhopper.util.Helper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Locale;
import java.util.function.Consumer;

import static com.graphhopper.util.Helper.nf;

/**
 * DataAccess-based storage for CH shortcuts. Stores shortcuts and CH levels sequentially using two DataAccess objects
 * and gives read/write access to the different shortcut and node fields.
 * &lt;p&gt;
 * This can be seen as an extension to a base graph: We assign a CH level to each node and add additional edges to
 * the graph ('shortcuts'). The shortcuts need to be ordered in a certain way, but this is not enforced here.
 *
 * @see CHStorageBuilder to build a valid storage that can be used for routing
 */
public class CHStorage {
<span class="fc" id="L44">    private static final Logger LOGGER = LoggerFactory.getLogger(CHStorage.class);</span>
    // we store double weights as integers (rounded to three decimal digits)
    private static final double WEIGHT_FACTOR = 1000;
    // the maximum integer value we can store
    private static final long MAX_STORED_INTEGER_WEIGHT = ((long) Integer.MAX_VALUE) &lt;&lt; 1;
    // the maximum double weight we can store. if this is exceeded the shortcut will gain infinite weight, potentially yielding connection-not-found errors
    private static final double MAX_WEIGHT = MAX_STORED_INTEGER_WEIGHT / WEIGHT_FACTOR;
    private static final double MIN_WEIGHT = 1 / WEIGHT_FACTOR;

    // shortcuts
    private final DataAccess shortcuts;
    private final int S_NODEA, S_NODEB, S_WEIGHT, S_SKIP_EDGE1, S_SKIP_EDGE2, S_ORIG_KEY_FIRST, S_ORIG_KEY_LAST;
    private int shortcutEntryBytes;
<span class="fc" id="L57">    private int shortcutCount = 0;</span>

    // nodes
    private final DataAccess nodesCH;
    private final int N_LEVEL, N_LAST_SC;
    private int nodeCHEntryBytes;
<span class="fc" id="L63">    private int nodeCount = -1;</span>

    private boolean edgeBased;
    // some shortcuts exceed the maximum storable weight, and we count them here
    private int numShortcutsExceedingWeight;

    // use this to report shortcuts with too small weights
    private Consumer&lt;LowWeightShortcut&gt; lowShortcutWeightConsumer;

    public static CHStorage fromGraph(BaseGraph baseGraph, CHConfig chConfig) {
<span class="fc" id="L73">        String name = chConfig.getName();</span>
<span class="fc" id="L74">        boolean edgeBased = chConfig.isEdgeBased();</span>
<span class="pc bpc" id="L75" title="1 of 2 branches missed.">        if (!baseGraph.isFrozen())</span>
<span class="nc" id="L76">            throw new IllegalStateException(&quot;graph must be frozen before we can create ch graphs&quot;);</span>
<span class="fc" id="L77">        CHStorage store = new CHStorage(baseGraph.getDirectory(), name, baseGraph.getSegmentSize(), edgeBased);</span>
<span class="fc" id="L78">        store.setLowShortcutWeightConsumer(s -&gt; {</span>
            // we just log these to find mapping errors
<span class="nc" id="L80">            NodeAccess nodeAccess = baseGraph.getNodeAccess();</span>
<span class="nc" id="L81">            LOGGER.warn(&quot;Setting weights smaller than &quot; + s.minWeight + &quot; is not allowed. &quot; +</span>
                    &quot;You passed: &quot; + s.weight + &quot; for the shortcut &quot; +
<span class="nc" id="L83">                    &quot; nodeA (&quot; + nodeAccess.getLat(s.nodeA) + &quot;,&quot; + nodeAccess.getLon(s.nodeA) +</span>
<span class="nc" id="L84">                    &quot; nodeB &quot; + nodeAccess.getLat(s.nodeB) + &quot;,&quot; + nodeAccess.getLon(s.nodeB));</span>
<span class="nc" id="L85">        });</span>
        // we use a rather small value here. this might result in more allocations later, but they should
        // not matter that much. if we expect a too large value the shortcuts DataAccess will end up
        // larger than needed, because we do not do something like trimToSize in the end.
<span class="fc" id="L89">        double expectedShortcuts = 0.3 * baseGraph.getEdges();</span>
<span class="fc" id="L90">        store.create(baseGraph.getNodes(), (int) expectedShortcuts);</span>
<span class="fc" id="L91">        return store;</span>
    }

<span class="fc" id="L94">    public CHStorage(Directory dir, String name, int segmentSize, boolean edgeBased) {</span>
<span class="fc" id="L95">        this.edgeBased = edgeBased;</span>
<span class="fc" id="L96">        this.nodesCH = dir.create(&quot;nodes_ch_&quot; + name, dir.getDefaultType(&quot;nodes_ch_&quot; + name, true), segmentSize);</span>
<span class="fc" id="L97">        this.shortcuts = dir.create(&quot;shortcuts_&quot; + name, dir.getDefaultType(&quot;shortcuts_&quot; + name, true), segmentSize);</span>
        // shortcuts are stored consecutively using this layout (the last two entries only exist for edge-based):
        // NODEA | NODEB | WEIGHT | SKIP_EDGE1 | SKIP_EDGE2 | S_ORIG_FIRST | S_ORIG_LAST
<span class="fc" id="L100">        S_NODEA = 0;</span>
<span class="fc" id="L101">        S_NODEB = S_NODEA + 4;</span>
<span class="fc" id="L102">        S_WEIGHT = S_NODEB + 4;</span>
<span class="fc" id="L103">        S_SKIP_EDGE1 = S_WEIGHT + 4;</span>
<span class="fc" id="L104">        S_SKIP_EDGE2 = S_SKIP_EDGE1 + 4;</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        S_ORIG_KEY_FIRST = S_SKIP_EDGE2 + (edgeBased ? 4 : 0);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">        S_ORIG_KEY_LAST = S_ORIG_KEY_FIRST + (edgeBased ? 4 : 0);</span>
<span class="fc" id="L107">        shortcutEntryBytes = S_ORIG_KEY_LAST + 4;</span>

        // nodes/levels are stored consecutively using this layout:
        // LEVEL | N_LAST_SC
<span class="fc" id="L111">        N_LEVEL = 0;</span>
<span class="fc" id="L112">        N_LAST_SC = N_LEVEL + 4;</span>
<span class="fc" id="L113">        nodeCHEntryBytes = N_LAST_SC + 4;</span>
<span class="fc" id="L114">    }</span>

    /**
     * Sets a callback called for shortcuts that are below the minimum weight. e.g. used to find/log mapping errors
     */
    public void setLowShortcutWeightConsumer(Consumer&lt;LowWeightShortcut&gt; lowWeightShortcutConsumer) {
<span class="fc" id="L120">        this.lowShortcutWeightConsumer = lowWeightShortcutConsumer;</span>
<span class="fc" id="L121">    }</span>

    /**
     * Creates a new storage. Alternatively we could load an existing one using {@link #loadExisting()}}.
     * The number of nodes must be given here while the expected number of shortcuts can
     * be given to prevent some memory allocations, but is not a requirement. When in doubt rather use a small value
     * so the resulting files/byte arrays won't be unnecessarily large.
     * todo: we could also trim down the shortcuts DataAccess when we are done adding shortcuts
     */
    public void create(int nodes, int expectedShortcuts) {
<span class="pc bpc" id="L131" title="1 of 2 branches missed.">        if (nodeCount &gt;= 0)</span>
<span class="nc" id="L132">            throw new IllegalStateException(&quot;CHStorage can only be created once&quot;);</span>
<span class="pc bpc" id="L133" title="1 of 2 branches missed.">        if (nodes &lt; 0)</span>
<span class="nc" id="L134">            throw new IllegalStateException(&quot;CHStorage must be created with a positive number of nodes&quot;);</span>
<span class="fc" id="L135">        nodesCH.create((long) nodes * nodeCHEntryBytes);</span>
<span class="fc" id="L136">        nodeCount = nodes;</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">        for (int node = 0; node &lt; nodes; node++)</span>
<span class="fc" id="L138">            setLastShortcut(toNodePointer(node), -1);</span>
<span class="fc" id="L139">        shortcuts.create((long) expectedShortcuts * shortcutEntryBytes);</span>
<span class="fc" id="L140">    }</span>

    public void flush() {
        // nodes
<span class="fc" id="L144">        nodesCH.setHeader(0, Constants.VERSION_NODE_CH);</span>
<span class="fc" id="L145">        nodesCH.setHeader(4, nodeCount);</span>
<span class="fc" id="L146">        nodesCH.setHeader(8, nodeCHEntryBytes);</span>
<span class="fc" id="L147">        nodesCH.flush();</span>

        // shortcuts
<span class="fc" id="L150">        shortcuts.setHeader(0, Constants.VERSION_SHORTCUT);</span>
<span class="fc" id="L151">        shortcuts.setHeader(4, shortcutCount);</span>
<span class="fc" id="L152">        shortcuts.setHeader(8, shortcutEntryBytes);</span>
<span class="fc" id="L153">        shortcuts.setHeader(12, numShortcutsExceedingWeight);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        shortcuts.setHeader(16, edgeBased ? 1 : 0);</span>
<span class="fc" id="L155">        shortcuts.flush();</span>
<span class="fc" id="L156">    }</span>

    public boolean loadExisting() {
<span class="pc bpc" id="L159" title="1 of 4 branches missed.">        if (!nodesCH.loadExisting() || !shortcuts.loadExisting())</span>
<span class="fc" id="L160">            return false;</span>

        // nodes
<span class="fc" id="L163">        int nodesCHVersion = nodesCH.getHeader(0);</span>
<span class="fc" id="L164">        GHUtility.checkDAVersion(nodesCH.getName(), Constants.VERSION_NODE_CH, nodesCHVersion);</span>
<span class="fc" id="L165">        nodeCount = nodesCH.getHeader(4);</span>
<span class="fc" id="L166">        nodeCHEntryBytes = nodesCH.getHeader(8);</span>

        // shortcuts
<span class="fc" id="L169">        int shortcutsVersion = shortcuts.getHeader(0);</span>
<span class="fc" id="L170">        GHUtility.checkDAVersion(shortcuts.getName(), Constants.VERSION_SHORTCUT, shortcutsVersion);</span>
<span class="fc" id="L171">        shortcutCount = shortcuts.getHeader(4);</span>
<span class="fc" id="L172">        shortcutEntryBytes = shortcuts.getHeader(8);</span>
<span class="fc" id="L173">        numShortcutsExceedingWeight = shortcuts.getHeader(12);</span>
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">        edgeBased = shortcuts.getHeader(16) == 1;</span>

<span class="fc" id="L176">        return true;</span>
    }

    public void close() {
<span class="fc" id="L180">        nodesCH.close();</span>
<span class="fc" id="L181">        shortcuts.close();</span>
<span class="fc" id="L182">    }</span>

    /**
     * Adds a shortcut to the storage. Shortcuts are stored in the same order they are added. The underlying DataAccess
     * object grows automatically when adding more shortcuts.
     */
    public int shortcutNodeBased(int nodeA, int nodeB, int accessFlags, double weight, int skip1, int skip2) {
<span class="pc bpc" id="L189" title="1 of 2 branches missed.">        if (edgeBased)</span>
<span class="nc" id="L190">            throw new IllegalArgumentException(&quot;Cannot add node-based shortcuts to edge-based CH&quot;);</span>
<span class="fc" id="L191">        return shortcut(nodeA, nodeB, accessFlags, weight, skip1, skip2);</span>
    }

    public int shortcutEdgeBased(int nodeA, int nodeB, int accessFlags, double weight, int skip1, int skip2, int origKeyFirst, int origKeyLast) {
<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (!edgeBased)</span>
<span class="nc" id="L196">            throw new IllegalArgumentException(&quot;Cannot add edge-based shortcuts to node-based CH&quot;);</span>
<span class="fc" id="L197">        int shortcut = shortcut(nodeA, nodeB, accessFlags, weight, skip1, skip2);</span>
<span class="fc" id="L198">        setOrigEdgeKeys(toShortcutPointer(shortcut), origKeyFirst, origKeyLast);</span>
<span class="fc" id="L199">        return shortcut;</span>
    }

    private int shortcut(int nodeA, int nodeB, int accessFlags, double weight, int skip1, int skip2) {
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">        if (shortcutCount == Integer.MAX_VALUE)</span>
<span class="nc" id="L204">            throw new IllegalStateException(&quot;Maximum shortcut count exceeded: &quot; + shortcutCount);</span>
<span class="pc bpc" id="L205" title="1 of 4 branches missed.">        if (lowShortcutWeightConsumer != null &amp;&amp; weight &lt; MIN_WEIGHT)</span>
<span class="nc" id="L206">            lowShortcutWeightConsumer.accept(new LowWeightShortcut(nodeA, nodeB, shortcutCount, weight, MIN_WEIGHT));</span>
<span class="fc" id="L207">        long shortcutPointer = (long) shortcutCount * shortcutEntryBytes;</span>
<span class="fc" id="L208">        shortcutCount++;</span>
<span class="fc" id="L209">        shortcuts.ensureCapacity((long) shortcutCount * shortcutEntryBytes);</span>
<span class="fc" id="L210">        int weightInt = weightFromDouble(weight);</span>
<span class="fc" id="L211">        setNodesAB(shortcutPointer, nodeA, nodeB, accessFlags);</span>
<span class="fc" id="L212">        setWeightInt(shortcutPointer, weightInt);</span>
<span class="fc" id="L213">        setSkippedEdges(shortcutPointer, skip1, skip2);</span>
<span class="fc" id="L214">        return shortcutCount - 1;</span>
    }

    /**
     * The number of nodes of this storage.
     */
    public int getNodes() {
<span class="fc" id="L221">        return nodeCount;</span>
    }

    /**
     * The number of shortcuts that were added to this storage
     */
    public int getShortcuts() {
<span class="fc" id="L228">        return shortcutCount;</span>
    }

    /**
     * To use the node getters/setters you need to convert node IDs to a nodePointer first
     */
    public long toNodePointer(int node) {
<span class="pc bpc" id="L235" title="2 of 4 branches missed.">        assert node &gt;= 0 &amp;&amp; node &lt; nodeCount : &quot;node not in bounds: [0, &quot; + nodeCount + &quot;[&quot;;</span>
<span class="fc" id="L236">        return (long) node * nodeCHEntryBytes;</span>
    }

    /**
     * To use the shortcut getters/setters you need to convert shortcut IDs to an shortcutPointer first
     */
    public long toShortcutPointer(int shortcut) {
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        assert shortcut &lt; shortcutCount : &quot;shortcut &quot; + shortcut + &quot; not in bounds [0, &quot; + shortcutCount + &quot;[&quot;;</span>
<span class="fc" id="L244">        return (long) shortcut * shortcutEntryBytes;</span>
    }

    public boolean isEdgeBased() {
<span class="fc" id="L248">        return edgeBased;</span>
    }

    public int getLastShortcut(long nodePointer) {
<span class="fc" id="L252">        return nodesCH.getInt(nodePointer + N_LAST_SC);</span>
    }

    public void setLastShortcut(long nodePointer, int shortcut) {
<span class="fc" id="L256">        nodesCH.setInt(nodePointer + N_LAST_SC, shortcut);</span>
<span class="fc" id="L257">    }</span>

    public int getLevel(long nodePointer) {
<span class="fc" id="L260">        return nodesCH.getInt(nodePointer + N_LEVEL);</span>
    }

    public void setLevel(long nodePointer, int level) {
<span class="fc" id="L264">        nodesCH.setInt(nodePointer + N_LEVEL, level);</span>
<span class="fc" id="L265">    }</span>

    private void setNodesAB(long shortcutPointer, int nodeA, int nodeB, int accessFlags) {
<span class="fc" id="L268">        shortcuts.setInt(shortcutPointer + S_NODEA, nodeA &lt;&lt; 1 | accessFlags &amp; PrepareEncoder.getScFwdDir());</span>
<span class="fc" id="L269">        shortcuts.setInt(shortcutPointer + S_NODEB, nodeB &lt;&lt; 1 | (accessFlags &amp; PrepareEncoder.getScBwdDir()) &gt;&gt; 1);</span>
<span class="fc" id="L270">    }</span>

    public void setWeight(long shortcutPointer, double weight) {
<span class="fc" id="L273">        setWeightInt(shortcutPointer, weightFromDouble(weight));</span>
<span class="fc" id="L274">    }</span>

    private void setWeightInt(long shortcutPointer, int weightInt) {
<span class="fc" id="L277">        shortcuts.setInt(shortcutPointer + S_WEIGHT, weightInt);</span>
<span class="fc" id="L278">    }</span>

    public void setSkippedEdges(long shortcutPointer, int edge1, int edge2) {
<span class="fc" id="L281">        shortcuts.setInt(shortcutPointer + S_SKIP_EDGE1, edge1);</span>
<span class="fc" id="L282">        shortcuts.setInt(shortcutPointer + S_SKIP_EDGE2, edge2);</span>
<span class="fc" id="L283">    }</span>

    public void setOrigEdgeKeys(long shortcutPointer, int origKeyFirst, int origKeyLast) {
<span class="pc bpc" id="L286" title="1 of 2 branches missed.">        if (!edgeBased)</span>
<span class="nc" id="L287">            throw new IllegalArgumentException(&quot;Setting orig edge keys is only possible for edge-based CH&quot;);</span>
<span class="fc" id="L288">        shortcuts.setInt(shortcutPointer + S_ORIG_KEY_FIRST, origKeyFirst);</span>
<span class="fc" id="L289">        shortcuts.setInt(shortcutPointer + S_ORIG_KEY_LAST, origKeyLast);</span>
<span class="fc" id="L290">    }</span>

    public int getNodeA(long shortcutPointer) {
<span class="fc" id="L293">        return shortcuts.getInt(shortcutPointer + S_NODEA) &gt;&gt;&gt; 1;</span>
    }

    public int getNodeB(long shortcutPointer) {
<span class="fc" id="L297">        return shortcuts.getInt(shortcutPointer + S_NODEB) &gt;&gt;&gt; 1;</span>
    }

    public boolean getFwdAccess(long shortcutPointer) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">        return (shortcuts.getInt(shortcutPointer + S_NODEA) &amp; 0x1) != 0;</span>
    }

    public boolean getBwdAccess(long shortcutPointer) {
<span class="fc bfc" id="L305" title="All 2 branches covered.">        return (shortcuts.getInt(shortcutPointer + S_NODEB) &amp; 0x1) != 0;</span>
    }

    public double getWeight(long shortcutPointer) {
<span class="fc" id="L309">        return weightToDouble(shortcuts.getInt(shortcutPointer + S_WEIGHT));</span>
    }

    public int getSkippedEdge1(long shortcutPointer) {
<span class="fc" id="L313">        return shortcuts.getInt(shortcutPointer + S_SKIP_EDGE1);</span>
    }

    public int getSkippedEdge2(long shortcutPointer) {
<span class="fc" id="L317">        return shortcuts.getInt(shortcutPointer + S_SKIP_EDGE2);</span>
    }

    public int getOrigEdgeKeyFirst(long shortcutPointer) {
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        assert edgeBased : &quot;orig edge keys are only available for edge-based CH&quot;;</span>
<span class="fc" id="L322">        return shortcuts.getInt(shortcutPointer + S_ORIG_KEY_FIRST);</span>
    }

    public int getOrigEdgeKeyLast(long shortcutPointer) {
<span class="pc bpc" id="L326" title="1 of 2 branches missed.">        assert edgeBased : &quot;orig edge keys are only available for edge-based CH&quot;;</span>
<span class="fc" id="L327">        return shortcuts.getInt(shortcutPointer + S_ORIG_KEY_LAST);</span>
    }

    public NodeOrderingProvider getNodeOrderingProvider() {
<span class="fc" id="L331">        int numNodes = getNodes();</span>
<span class="fc" id="L332">        final int[] nodeOrdering = new int[numNodes];</span>
        // the node ordering is the inverse of the ch levels
        // if we really want to save some memory it could be still reasonable to not create the node ordering here,
        // but search nodesCH for a given level on demand.
<span class="fc bfc" id="L336" title="All 2 branches covered.">        for (int i = 0; i &lt; numNodes; ++i) {</span>
<span class="fc" id="L337">            int level = getLevel(toNodePointer(i));</span>
<span class="fc" id="L338">            nodeOrdering[level] = i;</span>
        }
<span class="fc" id="L340">        return NodeOrderingProvider.fromArray(nodeOrdering);</span>
    }

    public void debugPrint() {
<span class="nc" id="L344">        final int printMax = 100;</span>
<span class="nc" id="L345">        System.out.println(&quot;nodesCH:&quot;);</span>
<span class="nc" id="L346">        String formatNodes = &quot;%12s | %12s | %12s \n&quot;;</span>
<span class="nc" id="L347">        System.out.format(Locale.ROOT, formatNodes, &quot;#&quot;, &quot;N_LAST_SC&quot;, &quot;N_LEVEL&quot;);</span>
<span class="nc bnc" id="L348" title="All 2 branches missed.">        for (int i = 0; i &lt; Math.min(nodeCount, printMax); ++i) {</span>
<span class="nc" id="L349">            long ptr = toNodePointer(i);</span>
<span class="nc" id="L350">            System.out.format(Locale.ROOT, formatNodes, i, getLastShortcut(ptr), getLevel(ptr));</span>
        }
<span class="nc bnc" id="L352" title="All 2 branches missed.">        if (nodeCount &gt; printMax) {</span>
<span class="nc" id="L353">            System.out.format(Locale.ROOT, &quot; ... %d more nodes&quot;, nodeCount - printMax);</span>
        }
<span class="nc" id="L355">        System.out.println(&quot;shortcuts:&quot;);</span>
<span class="nc" id="L356">        String formatShortcutsBase = &quot;%12s | %12s | %12s | %12s | %12s | %12s&quot;;</span>
<span class="nc" id="L357">        String formatShortcutExt = &quot; | %12s | %12s&quot;;</span>
<span class="nc" id="L358">        String header = String.format(Locale.ROOT, formatShortcutsBase, &quot;#&quot;, &quot;E_NODEA&quot;, &quot;E_NODEB&quot;, &quot;S_WEIGHT&quot;, &quot;S_SKIP_EDGE1&quot;, &quot;S_SKIP_EDGE2&quot;);</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">        if (isEdgeBased()) {</span>
<span class="nc" id="L360">            header += String.format(Locale.ROOT, formatShortcutExt, &quot;S_ORIG_FIRST&quot;, &quot;S_ORIG_LAST&quot;);</span>
        }
<span class="nc" id="L362">        System.out.println(header);</span>
<span class="nc bnc" id="L363" title="All 2 branches missed.">        for (int i = 0; i &lt; Math.min(shortcutCount, printMax); ++i) {</span>
<span class="nc" id="L364">            long ptr = toShortcutPointer(i);</span>
<span class="nc" id="L365">            String edgeString = String.format(Locale.ROOT, formatShortcutsBase,</span>
<span class="nc" id="L366">                    i,</span>
<span class="nc" id="L367">                    getNodeA(ptr),</span>
<span class="nc" id="L368">                    getNodeB(ptr),</span>
<span class="nc" id="L369">                    getWeight(ptr),</span>
<span class="nc" id="L370">                    getSkippedEdge1(ptr),</span>
<span class="nc" id="L371">                    getSkippedEdge2(ptr));</span>
<span class="nc bnc" id="L372" title="All 2 branches missed.">            if (edgeBased) {</span>
<span class="nc" id="L373">                edgeString += String.format(Locale.ROOT, formatShortcutExt,</span>
<span class="nc" id="L374">                        getOrigEdgeKeyFirst(ptr),</span>
<span class="nc" id="L375">                        getOrigEdgeKeyLast(ptr));</span>
            }
<span class="nc" id="L377">            System.out.println(edgeString);</span>
        }
<span class="nc bnc" id="L379" title="All 2 branches missed.">        if (shortcutCount &gt; printMax) {</span>
<span class="nc" id="L380">            System.out.printf(Locale.ROOT, &quot; ... %d more shortcut edges\n&quot;, shortcutCount - printMax);</span>
        }
<span class="nc" id="L382">    }</span>

    public long getCapacity() {
<span class="nc" id="L385">        return nodesCH.getCapacity() + shortcuts.getCapacity();</span>
    }

    public int getNumShortcutsExceedingWeight() {
<span class="fc" id="L389">        return numShortcutsExceedingWeight;</span>
    }

    public String toDetailsString() {
<span class="nc" id="L393">        return &quot;shortcuts:&quot; + nf(shortcutCount) + &quot; (&quot; + nf(shortcuts.getCapacity() / Helper.MB) + &quot;MB)&quot; +</span>
<span class="nc" id="L394">                &quot;, nodesCH:&quot; + nf(nodeCount) + &quot; (&quot; + nf(nodesCH.getCapacity() / Helper.MB) + &quot;MB)&quot;;</span>
    }

    public boolean isClosed() {
<span class="nc bnc" id="L398" title="All 2 branches missed.">        assert nodesCH.isClosed() == shortcuts.isClosed();</span>
<span class="nc" id="L399">        return nodesCH.isClosed();</span>
    }

    private int weightFromDouble(double weight) {
<span class="pc bpc" id="L403" title="1 of 2 branches missed.">        if (weight &lt; 0)</span>
<span class="nc" id="L404">            throw new IllegalArgumentException(&quot;weight cannot be negative but was &quot; + weight);</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        if (weight &lt; MIN_WEIGHT)</span>
<span class="nc" id="L406">            weight = MIN_WEIGHT;</span>
<span class="fc bfc" id="L407" title="All 2 branches covered.">        if (weight &gt;= MAX_WEIGHT) {</span>
<span class="fc" id="L408">            numShortcutsExceedingWeight++;</span>
<span class="fc" id="L409">            return (int) MAX_STORED_INTEGER_WEIGHT; // negative</span>
        } else
<span class="fc" id="L411">            return (int) Math.round(weight * WEIGHT_FACTOR);</span>
    }

    private double weightToDouble(int intWeight) {
        // If the value is too large (&gt; Integer.MAX_VALUE) the `int` is negative. Converted to `long` the JVM fills the
        // high bits with 1's which we remove via &quot;&amp; 0xFFFFFFFFL&quot; to get the unsigned value. (The L is necessary or prepend 8 zeros.)
<span class="fc" id="L417">        long weightLong = (long) intWeight &amp; 0xFFFFFFFFL;</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">        if (weightLong == MAX_STORED_INTEGER_WEIGHT)</span>
<span class="fc" id="L419">            return Double.POSITIVE_INFINITY;</span>
<span class="fc" id="L420">        double weight = weightLong / WEIGHT_FACTOR;</span>
<span class="pc bpc" id="L421" title="1 of 2 branches missed.">        if (weight &gt;= MAX_WEIGHT)</span>
<span class="nc" id="L422">            throw new IllegalArgumentException(&quot;too large shortcut weight &quot; + weight + &quot; should get infinity marker bits &quot;</span>
                    + MAX_STORED_INTEGER_WEIGHT);
<span class="fc" id="L424">        return weight;</span>
    }

    public static class LowWeightShortcut {
        int nodeA;
        int nodeB;
        int shortcut;
        double weight;
        double minWeight;

<span class="nc" id="L434">        public LowWeightShortcut(int nodeA, int nodeB, int shortcut, double weight, double minWeight) {</span>
<span class="nc" id="L435">            this.nodeA = nodeA;</span>
<span class="nc" id="L436">            this.nodeB = nodeB;</span>
<span class="nc" id="L437">            this.shortcut = shortcut;</span>
<span class="nc" id="L438">            this.weight = weight;</span>
<span class="nc" id="L439">            this.minWeight = minWeight;</span>
<span class="nc" id="L440">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>