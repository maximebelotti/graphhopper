<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RoadDensityCalculator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.util</a> &gt; <span class="el_source">RoadDensityCalculator.java</span></div><h1>RoadDensityCalculator.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package com.graphhopper.routing.util;

import com.carrotsearch.hppc.IntArrayDeque;
import com.carrotsearch.hppc.IntScatterSet;
import com.carrotsearch.hppc.IntSet;
import com.graphhopper.storage.Graph;
import com.graphhopper.storage.NodeAccess;
import com.graphhopper.util.EdgeExplorer;
import com.graphhopper.util.EdgeIterator;
import com.graphhopper.util.EdgeIteratorState;
import com.graphhopper.util.GHUtility;
import com.graphhopper.util.shapes.GHPoint;

import java.util.function.BiConsumer;
import java.util.function.ToDoubleFunction;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import static com.graphhopper.util.DistancePlaneProjection.DIST_PLANE;

public class RoadDensityCalculator {
    private final Graph graph;
    private final EdgeExplorer edgeExplorer;
    private final IntSet visited;
    private final IntArrayDeque deque;

<span class="nc" id="L45">    public RoadDensityCalculator(Graph graph) {</span>
<span class="nc" id="L46">        this.graph = graph;</span>
<span class="nc" id="L47">        this.edgeExplorer = graph.createEdgeExplorer();</span>
<span class="nc" id="L48">        visited = new IntScatterSet();</span>
<span class="nc" id="L49">        deque = new IntArrayDeque(100);</span>
<span class="nc" id="L50">    }</span>

    /**
     * Loops over all edges of the graph and calls the given edgeHandler for each edge. This is done in parallel using
     * the given number of threads. For every call we can calculate the road density using the provided thread local
     * road density calculator.
     */
    public static void calcRoadDensities(Graph graph, BiConsumer&lt;RoadDensityCalculator, EdgeIteratorState&gt; edgeHandler, int threads) {
<span class="nc" id="L58">        ThreadLocal&lt;RoadDensityCalculator&gt; calculator = ThreadLocal.withInitial(() -&gt; new RoadDensityCalculator(graph));</span>
<span class="nc" id="L59">        Stream&lt;Runnable&gt; roadDensityWorkers = IntStream.range(0, graph.getEdges())</span>
<span class="nc" id="L60">                .mapToObj(i -&gt; () -&gt; {</span>
<span class="nc" id="L61">                    EdgeIteratorState edge = graph.getEdgeIteratorState(i, Integer.MIN_VALUE);</span>
<span class="nc" id="L62">                    edgeHandler.accept(calculator.get(), edge);</span>
<span class="nc" id="L63">                });</span>
<span class="nc" id="L64">        GHUtility.runConcurrently(roadDensityWorkers, threads);</span>
<span class="nc" id="L65">    }</span>

    /**
     * @param radius         in meters
     * @param calcRoadFactor weighting function. use this to define how different kinds of roads shall contribute to the calculated road density
     * @return the road density in the vicinity of the given edge, i.e. the weighted road length divided by the squared radius
     */
    public double calcRoadDensity(EdgeIteratorState edge, double radius, ToDoubleFunction&lt;EdgeIteratorState&gt; calcRoadFactor) {
<span class="nc" id="L73">        visited.clear();</span>
<span class="nc" id="L74">        deque.head = deque.tail = 0;</span>
<span class="nc" id="L75">        double totalRoadWeight = 0;</span>
<span class="nc" id="L76">        NodeAccess na = graph.getNodeAccess();</span>
<span class="nc" id="L77">        int baseNode = edge.getBaseNode();</span>
<span class="nc" id="L78">        int adjNode = edge.getAdjNode();</span>
<span class="nc" id="L79">        GHPoint center = new GHPoint(getLat(na, baseNode, adjNode), getLon(na, baseNode, adjNode));</span>
<span class="nc" id="L80">        deque.addLast(baseNode);</span>
<span class="nc" id="L81">        deque.addLast(adjNode);</span>
<span class="nc" id="L82">        visited.add(baseNode);</span>
<span class="nc" id="L83">        visited.add(adjNode);</span>
        // we just do a BFS search and sum up all the road lengths
<span class="nc" id="L85">        final double radiusNormalized = DIST_PLANE.calcNormalizedDist(radius);</span>
        // for long tunnels or motorway sections where the distance between the exit points and the
        // center is larger than the radius it is important to continue the search even outside the radius
<span class="nc" id="L88">        final int minPolls = (int) (radius / 2);</span>
<span class="nc" id="L89">        int polls = 0;</span>
<span class="nc bnc" id="L90" title="All 2 branches missed.">        while (!deque.isEmpty()) {</span>
<span class="nc" id="L91">            int node = deque.removeFirst();</span>
<span class="nc" id="L92">            polls++;</span>
<span class="nc" id="L93">            double distance = DIST_PLANE.calcNormalizedDist(center.lat, center.lon, na.getLat(node), na.getLon(node));</span>
<span class="nc bnc" id="L94" title="All 4 branches missed.">            if (polls &gt; minPolls &amp;&amp; distance &gt; radiusNormalized)</span>
<span class="nc" id="L95">                continue;</span>
<span class="nc" id="L96">            EdgeIterator iter = edgeExplorer.setBaseNode(node);</span>
<span class="nc bnc" id="L97" title="All 2 branches missed.">            while (iter.next()) {</span>
<span class="nc bnc" id="L98" title="All 2 branches missed.">                if (visited.contains(iter.getAdjNode()))</span>
<span class="nc" id="L99">                    continue;</span>
<span class="nc" id="L100">                visited.add(iter.getAdjNode());</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                if (distance &lt;= radiusNormalized)</span>
<span class="nc" id="L102">                    totalRoadWeight += calcRoadFactor.applyAsDouble(iter);</span>
<span class="nc" id="L103">                deque.addLast(iter.getAdjNode());</span>
            }
<span class="nc" id="L105">        }</span>
<span class="nc" id="L106">        return totalRoadWeight / radius / radius;</span>
    }

    private static double getLat(NodeAccess na, int baseNode, int adjNode) {
<span class="nc" id="L110">        return (na.getLat(baseNode) + na.getLat(adjNode)) / 2;</span>
    }

    private static double getLon(NodeAccess na, int baseNode, int adjNode) {
<span class="nc" id="L114">        return (na.getLon(baseNode) + na.getLon(adjNode)) / 2;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>