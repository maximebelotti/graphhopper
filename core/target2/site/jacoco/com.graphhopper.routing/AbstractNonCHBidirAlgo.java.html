<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractNonCHBidirAlgo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing</a> &gt; <span class="el_source">AbstractNonCHBidirAlgo.java</span></div><h1>AbstractNonCHBidirAlgo.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.graphhopper.routing;

import com.carrotsearch.hppc.IntObjectMap;
import com.graphhopper.routing.util.EdgeFilter;
import com.graphhopper.routing.util.TraversalMode;
import com.graphhopper.routing.weighting.Weighting;
import com.graphhopper.storage.Graph;
import com.graphhopper.storage.NodeAccess;
import com.graphhopper.util.EdgeExplorer;
import com.graphhopper.util.EdgeIterator;
import com.graphhopper.util.EdgeIteratorState;
import com.graphhopper.util.GHUtility;

import java.util.PriorityQueue;

import static com.graphhopper.util.EdgeIterator.ANY_EDGE;

/**
 * Common subclass for bidirectional algorithms.
 *
 * @author Peter Karich
 * @author easbar
 * @see AbstractBidirCHAlgo for bidirectional CH algorithms
 */
public abstract class AbstractNonCHBidirAlgo extends AbstractBidirAlgo implements EdgeToEdgeRoutingAlgorithm {
    protected final Graph graph;
    protected final NodeAccess nodeAccess;
    protected final Weighting weighting;
    protected EdgeExplorer edgeExplorer;
    protected EdgeFilter additionalEdgeFilter;

    public AbstractNonCHBidirAlgo(Graph graph, Weighting weighting, TraversalMode tMode) {
<span class="fc" id="L50">        super(tMode);</span>
<span class="fc" id="L51">        this.weighting = weighting;</span>
<span class="pc bpc" id="L52" title="1 of 4 branches missed.">        if (weighting.hasTurnCosts() &amp;&amp; !tMode.isEdgeBased())</span>
<span class="nc" id="L53">            throw new IllegalStateException(&quot;Weightings supporting turn costs cannot be used with node-based traversal mode&quot;);</span>
<span class="fc" id="L54">        this.graph = graph;</span>
<span class="fc" id="L55">        this.nodeAccess = graph.getNodeAccess();</span>
<span class="fc" id="L56">        edgeExplorer = graph.createEdgeExplorer();</span>
<span class="fc" id="L57">        int size = Math.min(Math.max(200, graph.getNodes() / 10), 150_000);</span>
<span class="fc" id="L58">        initCollections(size);</span>
<span class="fc" id="L59">    }</span>

    /**
     * Creates a new entry of the shortest path tree (a {@link SPTEntry} or one of its subclasses) during a dijkstra
     * expansion.
     *
     * @param edge    the edge that is currently processed for the expansion
     * @param weight  the weight the shortest path three entry should carry
     * @param parent  the parent entry of in the shortest path tree
     * @param reverse true if we are currently looking at the backward search, false otherwise
     */
    protected abstract SPTEntry createEntry(EdgeIteratorState edge, double weight, SPTEntry parent, boolean reverse);

    protected DefaultBidirPathExtractor createPathExtractor(Graph graph, Weighting weighting) {
<span class="fc" id="L73">        return new DefaultBidirPathExtractor(graph, weighting);</span>
    }

    protected void postInitFrom() {
<span class="fc bfc" id="L77" title="All 2 branches covered.">        if (fromOutEdge == ANY_EDGE) {</span>
<span class="fc" id="L78">            fillEdgesFrom();</span>
        } else {
<span class="fc bfc" id="L80" title="All 2 branches covered.">            fillEdgesFromUsingFilter(edgeState -&gt; edgeState.getEdge() == fromOutEdge);</span>
        }
<span class="fc" id="L82">    }</span>

    protected void postInitTo() {
<span class="fc bfc" id="L85" title="All 2 branches covered.">        if (toInEdge == ANY_EDGE) {</span>
<span class="fc" id="L86">            fillEdgesTo();</span>
        } else {
<span class="fc bfc" id="L88" title="All 2 branches covered.">            fillEdgesToUsingFilter(edgeState -&gt; edgeState.getEdge() == toInEdge);</span>
        }
<span class="fc" id="L90">    }</span>

    /**
     * @param edgeFilter edge filter used to filter edges during {@link #fillEdgesFrom()}
     */
    protected void fillEdgesFromUsingFilter(EdgeFilter edgeFilter) {
<span class="fc" id="L96">        additionalEdgeFilter = edgeFilter;</span>
<span class="pc bpc" id="L97" title="1 of 2 branches missed.">        finishedFrom = !fillEdgesFrom();</span>
<span class="fc" id="L98">        additionalEdgeFilter = null;</span>
<span class="fc" id="L99">    }</span>

    /**
     * @see #fillEdgesFromUsingFilter(EdgeFilter)
     */
    protected void fillEdgesToUsingFilter(EdgeFilter edgeFilter) {
<span class="fc" id="L105">        additionalEdgeFilter = edgeFilter;</span>
<span class="pc bpc" id="L106" title="1 of 2 branches missed.">        finishedTo = !fillEdgesTo();</span>
<span class="fc" id="L107">        additionalEdgeFilter = null;</span>
<span class="fc" id="L108">    }</span>

    @Override
    boolean fillEdgesFrom() {
        while (true) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">            if (pqOpenSetFrom.isEmpty())</span>
<span class="fc" id="L114">                return false;</span>
<span class="fc" id="L115">            currFrom = pqOpenSetFrom.poll();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (!currFrom.isDeleted())</span>
<span class="fc" id="L117">                break;</span>
        }
<span class="fc" id="L119">        visitedCountFrom++;</span>
<span class="pc bpc" id="L120" title="1 of 2 branches missed.">        if (fromEntryCanBeSkipped()) {</span>
<span class="nc" id="L121">            return true;</span>
        }
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">        if (fwdSearchCanBeStopped()) {</span>
<span class="nc" id="L124">            return false;</span>
        }
<span class="fc" id="L126">        bestWeightMapOther = bestWeightMapTo;</span>
<span class="fc" id="L127">        fillEdges(currFrom, pqOpenSetFrom, bestWeightMapFrom, false);</span>
<span class="fc" id="L128">        return true;</span>
    }

    @Override
    boolean fillEdgesTo() {
        while (true) {
<span class="fc bfc" id="L134" title="All 2 branches covered.">            if (pqOpenSetTo.isEmpty())</span>
<span class="fc" id="L135">                return false;</span>
<span class="fc" id="L136">            currTo = pqOpenSetTo.poll();</span>
<span class="fc bfc" id="L137" title="All 2 branches covered.">            if (!currTo.isDeleted())</span>
<span class="fc" id="L138">                break;</span>
        }
<span class="fc" id="L140">        visitedCountTo++;</span>
<span class="pc bpc" id="L141" title="1 of 2 branches missed.">        if (toEntryCanBeSkipped()) {</span>
<span class="nc" id="L142">            return true;</span>
        }
<span class="pc bpc" id="L144" title="1 of 2 branches missed.">        if (bwdSearchCanBeStopped()) {</span>
<span class="nc" id="L145">            return false;</span>
        }
<span class="fc" id="L147">        bestWeightMapOther = bestWeightMapFrom;</span>
<span class="fc" id="L148">        fillEdges(currTo, pqOpenSetTo, bestWeightMapTo, true);</span>
<span class="fc" id="L149">        return true;</span>
    }

    private void fillEdges(SPTEntry currEdge, PriorityQueue&lt;SPTEntry&gt; prioQueue, IntObjectMap&lt;SPTEntry&gt; bestWeightMap, boolean reverse) {
<span class="fc" id="L153">        EdgeIterator iter = edgeExplorer.setBaseNode(currEdge.adjNode);</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        while (iter.next()) {</span>
<span class="fc bfc" id="L155" title="All 2 branches covered.">            if (!accept(iter, currEdge.edge))</span>
<span class="fc" id="L156">                continue;</span>

<span class="fc" id="L158">            final double weight = calcWeight(iter, currEdge, reverse);</span>
<span class="fc bfc" id="L159" title="All 2 branches covered.">            if (Double.isInfinite(weight)) {</span>
<span class="fc" id="L160">                continue;</span>
            }
<span class="fc" id="L162">            final int traversalId = traversalMode.createTraversalId(iter, reverse);</span>
<span class="fc" id="L163">            SPTEntry entry = bestWeightMap.get(traversalId);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">            if (entry == null) {</span>
<span class="fc" id="L165">                entry = createEntry(iter, weight, currEdge, reverse);</span>
<span class="fc" id="L166">                bestWeightMap.put(traversalId, entry);</span>
<span class="fc" id="L167">                prioQueue.add(entry);</span>
<span class="fc bfc" id="L168" title="All 2 branches covered.">            } else if (entry.getWeightOfVisitedPath() &gt; weight) {</span>
                // flagging this entry, so it will be ignored when it is polled the next time
<span class="fc" id="L170">                entry.setDeleted();</span>
<span class="fc bfc" id="L171" title="All 6 branches covered.">                boolean isBestEntry = reverse ? (entry == bestBwdEntry) : (entry == bestFwdEntry);</span>
<span class="fc" id="L172">                entry = createEntry(iter, weight, currEdge, reverse);</span>
<span class="fc" id="L173">                bestWeightMap.put(traversalId, entry);</span>
<span class="fc" id="L174">                prioQueue.add(entry);</span>
                // if this is the best entry we need to update the best reference as well
<span class="fc bfc" id="L176" title="All 2 branches covered.">                if (isBestEntry)</span>
<span class="fc bfc" id="L177" title="All 2 branches covered.">                    if (reverse)</span>
<span class="fc" id="L178">                        bestBwdEntry = entry;</span>
                    else
<span class="fc" id="L180">                        bestFwdEntry = entry;</span>
            } else
                continue;

<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (updateBestPath) {</span>
                // only needed for edge-based -&gt; skip the calculation and use dummy value otherwise
<span class="fc bfc" id="L186" title="All 2 branches covered.">                double edgeWeight = traversalMode.isEdgeBased() ? weighting.calcEdgeWeight(iter, reverse) : Double.POSITIVE_INFINITY;</span>
                // todo: performance - if bestWeightMapOther.get(traversalId) == null, updateBestPath will exit early and we might
                // have calculated the edgeWeight unnecessarily
<span class="fc" id="L189">                updateBestPath(edgeWeight, entry, EdgeIterator.NO_EDGE, traversalId, reverse);</span>
            }
<span class="fc" id="L191">        }</span>
<span class="fc" id="L192">    }</span>

    protected double calcWeight(EdgeIteratorState iter, SPTEntry currEdge, boolean reverse) {
        // note that for node-based routing the weights will be wrong in case the weighting is returning non-zero
        // turn weights, see discussion in #1960
<span class="fc" id="L197">        return GHUtility.calcWeightWithTurnWeight(weighting, iter, reverse, currEdge.edge) + currEdge.getWeightOfVisitedPath();</span>
    }

    @Override
    protected double getInEdgeWeight(SPTEntry entry) {
<span class="nc" id="L202">        return weighting.calcEdgeWeight(graph.getEdgeIteratorState(entry.edge, entry.adjNode), false);</span>
    }

    @Override
    protected Path extractPath() {
<span class="fc bfc" id="L207" title="All 2 branches covered.">        if (finished())</span>
<span class="fc" id="L208">            return createPathExtractor(graph, weighting).extract(bestFwdEntry, bestBwdEntry, bestWeight);</span>

<span class="fc" id="L210">        return createEmptyPath();</span>
    }

    protected boolean accept(EdgeIteratorState iter, int prevOrNextEdgeId) {
        // for edge-based traversal we leave it for TurnWeighting to decide whether or not a u-turn is acceptable,
        // but for node-based traversal we exclude such a turn for performance reasons already here
<span class="fc bfc" id="L216" title="All 4 branches covered.">        if (!traversalMode.isEdgeBased() &amp;&amp; iter.getEdge() == prevOrNextEdgeId)</span>
<span class="fc" id="L217">            return false;</span>

<span class="fc bfc" id="L219" title="All 4 branches covered.">        return additionalEdgeFilter == null || additionalEdgeFilter.accept(iter);</span>
    }

    protected Path createEmptyPath() {
<span class="fc" id="L223">        return new Path(graph);</span>
    }

    @Override
    public String toString() {
<span class="nc" id="L228">        return getName() + &quot;|&quot; + weighting;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>