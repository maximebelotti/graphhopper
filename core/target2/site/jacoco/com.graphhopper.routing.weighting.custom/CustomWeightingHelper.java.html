<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CustomWeightingHelper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.weighting.custom</a> &gt; <span class="el_source">CustomWeightingHelper.java</span></div><h1>CustomWeightingHelper.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.graphhopper.routing.weighting.custom;

import com.graphhopper.json.MinMax;
import com.graphhopper.json.Statement;
import com.graphhopper.routing.ev.EncodedValueLookup;
import com.graphhopper.util.*;
import com.graphhopper.util.shapes.BBox;
import com.graphhopper.util.shapes.Polygon;

import java.util.List;
import java.util.Map;

/**
 * This class is for internal usage only. It is subclassed by Janino, then special expressions are
 * injected into init, getSpeed and getPriority. At the end an instance is created and used in CustomWeighting.
 */
public class CustomWeightingHelper {
<span class="fc" id="L35">    static double GLOBAL_MAX_SPEED = 999;</span>
<span class="fc" id="L36">    static double GLOBAL_PRIORITY = 1;</span>

    protected EncodedValueLookup lookup;
    protected CustomModel customModel;

<span class="fc" id="L41">    protected CustomWeightingHelper() {</span>
<span class="fc" id="L42">    }</span>

    public void init(CustomModel customModel, EncodedValueLookup lookup, Map&lt;String, JsonFeature&gt; areas) {
<span class="fc" id="L45">        this.lookup = lookup;</span>
<span class="fc" id="L46">        this.customModel = customModel;</span>
<span class="fc" id="L47">    }</span>

    public double getPriority(EdgeIteratorState edge, boolean reverse) {
<span class="nc" id="L50">        return getRawPriority(edge, reverse);</span>
    }

    public double getSpeed(EdgeIteratorState edge, boolean reverse) {
<span class="nc" id="L54">        return getRawSpeed(edge, reverse);</span>
    }

    protected final double getRawSpeed(EdgeIteratorState edge, boolean reverse) {
<span class="nc" id="L58">        return 1;</span>
    }

    protected final double getRawPriority(EdgeIteratorState edge, boolean reverse) {
<span class="nc" id="L62">        return 1;</span>
    }

    public final double calcMaxSpeed() {
<span class="fc" id="L66">        MinMax minMaxSpeed = new MinMax(0, GLOBAL_MAX_SPEED);</span>
<span class="fc" id="L67">        FindMinMax.findMinMax(minMaxSpeed, customModel.getSpeed(), lookup);</span>
<span class="pc bpc" id="L68" title="1 of 2 branches missed.">        if (minMaxSpeed.min &lt; 0)</span>
<span class="nc" id="L69">            throw new IllegalArgumentException(&quot;speed has to be &gt;=0 but can be negative (&quot; + minMaxSpeed.min + &quot;)&quot;);</span>
<span class="pc bpc" id="L70" title="1 of 2 branches missed.">        if (minMaxSpeed.max &lt;= 0)</span>
<span class="nc" id="L71">            throw new IllegalArgumentException(&quot;maximum speed has to be &gt;0 but was &quot; + minMaxSpeed.max);</span>
<span class="pc bpc" id="L72" title="1 of 2 branches missed.">        if (minMaxSpeed.max == GLOBAL_MAX_SPEED)</span>
<span class="nc" id="L73">            throw new IllegalArgumentException(&quot;The first statement for 'speed' must be unconditionally to set the speed. But it was &quot; + customModel.getSpeed().get(0));</span>

<span class="fc" id="L75">        return minMaxSpeed.max;</span>
    }

    public final double calcMaxPriority() {
<span class="fc" id="L79">        MinMax minMaxPriority = new MinMax(0, GLOBAL_PRIORITY);</span>
<span class="fc" id="L80">        List&lt;Statement&gt; statements = customModel.getPriority();</span>
<span class="fc bfc" id="L81" title="All 4 branches covered.">        if (!statements.isEmpty() &amp;&amp; &quot;true&quot;.equals(statements.get(0).condition())) {</span>
<span class="fc" id="L82">            String value = statements.get(0).value();</span>
<span class="fc bfc" id="L83" title="All 2 branches covered.">            if (lookup.hasEncodedValue(value))</span>
<span class="fc" id="L84">                minMaxPriority.max = lookup.getDecimalEncodedValue(value).getMaxOrMaxStorableDecimal();</span>
        }
<span class="fc" id="L86">        FindMinMax.findMinMax(minMaxPriority, statements, lookup);</span>
<span class="pc bpc" id="L87" title="1 of 2 branches missed.">        if (minMaxPriority.min &lt; 0)</span>
<span class="nc" id="L88">            throw new IllegalArgumentException(&quot;priority has to be &gt;=0 but can be negative (&quot; + minMaxPriority.min + &quot;)&quot;);</span>
<span class="pc bpc" id="L89" title="1 of 2 branches missed.">        if (minMaxPriority.max &lt; 0)</span>
<span class="nc" id="L90">            throw new IllegalArgumentException(&quot;maximum priority has to be &gt;=0 but was &quot; + minMaxPriority.max);</span>
<span class="fc" id="L91">        return minMaxPriority.max;</span>
    }

    public static boolean in(Polygon p, EdgeIteratorState edge) {
<span class="fc" id="L95">        BBox edgeBBox = GHUtility.createBBox(edge);</span>
<span class="fc" id="L96">        BBox polyBBOX = p.getBounds();</span>
<span class="fc bfc" id="L97" title="All 2 branches covered.">        if (!polyBBOX.intersects(edgeBBox))</span>
<span class="fc" id="L98">            return false;</span>
<span class="fc bfc" id="L99" title="All 4 branches covered.">        if (p.isRectangle() &amp;&amp; polyBBOX.contains(edgeBBox))</span>
<span class="fc" id="L100">            return true;</span>
<span class="fc" id="L101">        return p.intersects(edge.fetchWayGeometry(FetchMode.ALL).makeImmutable()); // TODO PERF: cache bbox and edge wayGeometry for multiple area</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>