<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>LMApproximator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">GraphHopper Core</a> &gt; <a href="index.source.html" class="el_package">com.graphhopper.routing.lm</a> &gt; <span class="el_source">LMApproximator.java</span></div><h1>LMApproximator.java</h1><pre class="source lang-java linenums">/*
 *  Licensed to GraphHopper GmbH under one or more contributor
 *  license agreements. See the NOTICE file distributed with this work for
 *  additional information regarding copyright ownership.
 *
 *  GraphHopper GmbH licenses this file to you under the Apache License,
 *  Version 2.0 (the &quot;License&quot;); you may not use this file except in
 *  compliance with the License. You may obtain a copy of the License at
 *
 *       http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */
package com.graphhopper.routing.lm;

import com.graphhopper.routing.Dijkstra;
import com.graphhopper.routing.util.TraversalMode;
import com.graphhopper.routing.weighting.BeelineWeightApproximator;
import com.graphhopper.routing.weighting.WeightApproximator;
import com.graphhopper.routing.weighting.Weighting;
import com.graphhopper.storage.Graph;

import java.util.Arrays;

/**
 * This class is a weight approximation based on precalculated landmarks.
 *
 * @author Peter Karich
 */
public class LMApproximator implements WeightApproximator {

    private final LandmarkStorage lms;
    // the weighting used for the LM preparation
    private final Weighting lmWeighting;
    // the weighting used for the current path calculation
    private final Weighting routingWeighting;
    private final int[] activeLandmarkIndices;
    private final int[] weightsFromActiveLandmarksToT;
    private final int[] weightsFromTToActiveLandmarks;
<span class="fc" id="L44">    private double epsilon = 1;</span>
<span class="fc" id="L45">    private int towerNodeNextToT = -1;</span>
    private double weightFromTToTowerNode;
<span class="fc" id="L47">    private boolean recalculateActiveLandmarks = true;</span>
    private final double factor;
    private final boolean reverse;
    private final int maxBaseNodes;
    private final Graph graph;
    private final WeightApproximator fallBackApproximation;
    private final WeightApproximator beelineApproximation;
<span class="fc" id="L54">    private boolean fallback = false;</span>

    /**
     * @param weighting the weighting used for the current path calculation, not necessarily the same that we used for the LM preparation.
     *                  All edge weights must be larger or equal compared to those used for the preparation.
     */
    public static LMApproximator forLandmarks(Graph g, Weighting weighting, LandmarkStorage lms, int activeLM) {
<span class="fc" id="L61">        return new LMApproximator(g, lms.getWeighting(), weighting, lms.getBaseNodes(), lms, activeLM, lms.getFactor(), false);</span>
    }

    public LMApproximator(Graph graph, Weighting lmWeighting, Weighting routingWeighting, int maxBaseNodes, LandmarkStorage lms, int activeCount,
<span class="fc" id="L65">                          double factor, boolean reverse) {</span>
<span class="fc" id="L66">        this.reverse = reverse;</span>
<span class="fc" id="L67">        this.lms = lms;</span>
<span class="fc" id="L68">        this.factor = factor;</span>
<span class="pc bpc" id="L69" title="1 of 2 branches missed.">        if (activeCount &gt; lms.getLandmarkCount())</span>
<span class="nc" id="L70">            throw new IllegalArgumentException(&quot;Active landmarks &quot; + activeCount</span>
<span class="nc" id="L71">                    + &quot; should be lower or equals to landmark count &quot; + lms.getLandmarkCount());</span>

<span class="fc" id="L73">        activeLandmarkIndices = new int[activeCount];</span>
<span class="fc" id="L74">        Arrays.fill(activeLandmarkIndices, -1);</span>
<span class="fc" id="L75">        weightsFromActiveLandmarksToT = new int[activeCount];</span>
<span class="fc" id="L76">        weightsFromTToActiveLandmarks = new int[activeCount];</span>

<span class="fc" id="L78">        this.graph = graph;</span>
<span class="fc" id="L79">        this.lmWeighting = lmWeighting;</span>
<span class="fc" id="L80">        this.routingWeighting = routingWeighting;</span>
<span class="fc" id="L81">        this.fallBackApproximation = new BeelineWeightApproximator(graph.getNodeAccess(), lmWeighting);</span>
<span class="fc" id="L82">        this.beelineApproximation = new BeelineWeightApproximator(graph.getNodeAccess(), routingWeighting);</span>
<span class="fc" id="L83">        this.maxBaseNodes = maxBaseNodes;</span>
<span class="fc" id="L84">    }</span>

    /**
     * Increase approximation with higher epsilon
     */
    public LMApproximator setEpsilon(double epsilon) {
<span class="fc" id="L90">        this.epsilon = epsilon;</span>
<span class="fc" id="L91">        return this;</span>
    }

    @Override
    public double approximate(final int v) {
<span class="fc bfc" id="L96" title="All 6 branches covered.">        if (!recalculateActiveLandmarks &amp;&amp; fallback || lms.isEmpty())</span>
<span class="fc" id="L97">            return fallBackApproximation.approximate(v);</span>

<span class="fc bfc" id="L99" title="All 2 branches covered.">        if (v &gt;= maxBaseNodes) {</span>
            // handle virtual node
<span class="fc" id="L101">            return 0;</span>
        }

<span class="fc bfc" id="L104" title="All 2 branches covered.">        if (v == towerNodeNextToT)</span>
<span class="fc" id="L105">            return 0;</span>

        // select better active landmarks, LATER: use 'success' statistics about last active landmark
        // we have to update the priority queues and the maps if done in the middle of the search http://cstheory.stackexchange.com/q/36355/13229
<span class="fc bfc" id="L109" title="All 2 branches covered.">        if (recalculateActiveLandmarks) {</span>
<span class="fc" id="L110">            recalculateActiveLandmarks = false;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">            if (lms.chooseActiveLandmarks(v, towerNodeNextToT, activeLandmarkIndices, reverse)) {</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">                for (int i = 0; i &lt; activeLandmarkIndices.length; i++) {</span>
<span class="fc" id="L113">                    weightsFromActiveLandmarksToT[i] = lms.getFromWeight(activeLandmarkIndices[i], towerNodeNextToT);</span>
<span class="fc" id="L114">                    weightsFromTToActiveLandmarks[i] = lms.getToWeight(activeLandmarkIndices[i], towerNodeNextToT);</span>
                }
            } else {
                // note: fallback==true means forever true!
<span class="fc" id="L118">                fallback = true;</span>
<span class="fc" id="L119">                return fallBackApproximation.approximate(v);</span>
            }
        }
<span class="fc" id="L122">        double lmApproximation = Math.max(0.0, (getRemainingWeightUnderestimationUpToTowerNode(v) - weightFromTToTowerNode) * epsilon);</span>
        // Since both the LM and the beeline approximations underestimate the real remaining weight the larger one is
        // more accurate. For example when the speed is reduced for all roads the beeline approximation adjusts automatically
        // to the reduced global maximum speed, while the LM approximation becomes worse.
<span class="fc" id="L126">        return Math.max(lmApproximation, beelineApproximation.approximate(v));</span>
    }

    private double getRemainingWeightUnderestimationUpToTowerNode(int v) {
<span class="fc" id="L130">        int maxWeightInt = 0;</span>
<span class="fc bfc" id="L131" title="All 2 branches covered.">        for (int i = 0; i &lt; activeLandmarkIndices.length; i++) {</span>
<span class="fc" id="L132">            int resultInt = approximateForLandmark(i, v);</span>
<span class="fc" id="L133">            maxWeightInt = Math.max(maxWeightInt, resultInt);</span>
        }
        // Round down, we need to be an underestimator.
<span class="fc" id="L136">        return (maxWeightInt - 1) * factor;</span>
    }

    private int approximateForLandmark(int i, int v) {
        // ---&gt; means shortest path, d means length of shortest path
        // but remember that d(v,t) != d(t,v)
        //
        // Suppose we are at v, want to go to t, and are looking at a landmark LM,
        // preferably behind t.
        //
        //   ---&gt; t --&gt;
        // v ---------&gt; LM
        //
        // We know distances from everywhere to LM. From the triangle inequality for shortest-path distances we get:
        //  I)  d(v,t) + d(t,LM) &gt;= d(v,LM), so d(v,t) &gt;= d(v,LM) - d(t,LM)
        //
        // Now suppose LM is behind us:
        //
        //    ---&gt; v --&gt;
        // LM ---------&gt; t
        //
        // We also know distances from LM to everywhere, so we get:
        //  II) d(LM,v) + d(v,t) &gt;= d(LM,t), so d(v,t) &gt;= d(LM,t) - d(LM,v)
        //
        // Both equations hold in the general case, so we just pick the tighter approximation.
        // (The other one will probably be negative.)
        //
        // Note that when routing backwards we want to approximate d(t,v), not d(v,t).
        // When we flip all the arrows in the two figures, we get
        //  III)  d(t,v)  + d(LM,t) &gt;= d(LM,v), so d(t,v) &gt;= d(LM,v) - d(LM,t)
        //   IV)  d(v,LM) + d(t,v)  &gt;= d(t,LM), so d(t,v) &gt;= d(t,LM) - d(v,LM)
        //
        // ...and we can get the right-hand sides of III) and IV) by multiplying those of II) and I) by -1.

<span class="fc" id="L170">        int rhs1Int = lms.getToWeight(activeLandmarkIndices[i], v) - weightsFromTToActiveLandmarks[i];</span>
<span class="fc" id="L171">        int rhs2Int = weightsFromActiveLandmarksToT[i] - lms.getFromWeight(activeLandmarkIndices[i], v);</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">        if (reverse) {</span>
<span class="fc" id="L174">            rhs1Int *= -1;</span>
<span class="fc" id="L175">            rhs2Int *= -1;</span>
        }
<span class="fc" id="L177">        return Math.max(rhs1Int, rhs2Int);</span>
    }

    @Override
    public void setTo(int t) {
<span class="fc" id="L182">        this.fallBackApproximation.setTo(t);</span>
<span class="fc" id="L183">        this.beelineApproximation.setTo(t);</span>
<span class="fc" id="L184">        findClosestRealNode(t);</span>
<span class="fc" id="L185">    }</span>

    private void findClosestRealNode(int t) {
<span class="fc" id="L188">        Dijkstra dijkstra = new Dijkstra(graph, lmWeighting, TraversalMode.NODE_BASED) {</span>
            @Override
            protected boolean finished() {
<span class="fc" id="L191">                towerNodeNextToT = currEdge.adjNode;</span>
<span class="fc" id="L192">                weightFromTToTowerNode = currEdge.weight;</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                return currEdge.adjNode &lt; maxBaseNodes;</span>
            }

            // We only expect a very short search
            @Override
            protected void initCollections(int size) {
<span class="fc" id="L199">                super.initCollections(2);</span>
<span class="fc" id="L200">            }</span>
        };
<span class="fc" id="L202">        dijkstra.calcPath(t, -1);</span>
<span class="fc" id="L203">    }</span>

    @Override
    public WeightApproximator reverse() {
<span class="pc bpc" id="L207" title="1 of 2 branches missed.">        return new LMApproximator(graph, lmWeighting, routingWeighting, maxBaseNodes, lms, activeLandmarkIndices.length, factor, !reverse);</span>
    }

    @Override
    public double getSlack() {
<span class="fc" id="L212">        return lms.getFactor();</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L217">        return &quot;landmarks&quot;;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>